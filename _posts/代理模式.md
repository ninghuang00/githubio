---
title: 代理模式
categories:
  - 笔记
tags:
  - 代理模式
  - 正向代理
  - 反向代理
date: 2018-08-04 15:03:50
---
 这是摘要
 <!-- more -->


## 正向代理
{% asset_img 多进程多线程的对比.png 多进程多线程的对比%}
正向代理的用途
1. 突破访问限制
通过代理服务器，可以突破自身IP访问限制，访问国外网站，教育网等。
2. 提高访问速度 通常代理服务器都设置一个较大的硬盘缓冲区，会将部分请求的响应保存到缓冲区中，当其他用户再访问相同的信息时,则直接由缓冲区中取出信息，传给用户，以提高访问速度。
3. 隐藏客户端真实IP 
上网者也可以通过这种方法隐藏自己的IP，免受攻击。

## 反向代理
{% asset_img 反向代理.png 反向代理%}
1. 隐藏服务器真实IP 
使用反向代理，可以对客户端隐藏服务器的IP地址。
2. 负载均衡 
反向代理服务器可以做负载均衡，根据所有真实服务器的负载情况，将客户端请求分发到不同的真实服务器上。
3. 提高访问速度 
反向代理服务器可以对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务，提高访问速度。
4. 提供安全保障 
反向代理服务器可以作为应用层防火墙，为网站提供对基于Web的攻击行为（例如DoS/DDoS）的防护，更容易排查恶意软件等。还可以为后端服务器统一提供加密和SSL加速（如SSL终端代理），提供HTTP访问认证等。

## 代理模式
代理模式可以对代理对象进行增强,不过主要还是对代理对象的访问进行拦截
### 静态代理
{% asset_img 静态代理代码.png 静态代理%}
1. 创建代理的步骤:
	1. 首先定义一个代理类并实现要代理的接口
	2. 将要代理的接口声明为成员属性,一种是直接new一个要代理的对象(这种方式下使用代理的人甚至都不知道被代理对象的存在),另一种是将要代理的对象作为参数传入(这样就和装饰模式有点像)
	3. 定义代理类的构造函数,在构造函数张
	4. 实现接口的方法,并在方法中调用构造函数中传入的代理对象的方法,这个时候就可以对代理对象进行加强或者拦截
2. 优点
	1. 在不改变目标对象的前提下,对目标对象的功能进行拓展
3. 缺点
	2. 代理类和目标类几乎一样,目标类多的话,代理类也很多,代码几乎重复
	1. 因为代理类和和目标类要实现相同的接口,一旦接口中增加新功能,两个类都要维护

### 动态代理
#### JDK动态代理
1. 优点:
代理类不用实现目标类实现的接口,但是要将目标类的接口作为参数传入
2. 缺点
目标类需要有实现的接口才行,不然无法使用JDK动态代理
3. 创建代理对象的核心方法
```java
//Proxy类的静态方法
public static Object newProxyInstance(ClassLoader loader,
                                          Class<?>[] interfaces,
                                          InvocationHandler h) //关键接口
```
4. 用代理工厂类举例:
```java
public class ProxyFactory{
   //维护一个目标对象
   private Object target;
   public ProxyFactory(Object target){
       this.target=target;
   }
  //给目标对象生成代理对象
   public Object getProxyInstance(){
       return Proxy.newProxyInstance(
               target.getClass().getClassLoader(),//获取类加载器
               target.getClass().getInterfaces(),//获取接口
               new InvocationHandler() {//实现匿名内部类,使用反射调用目标类方法,进行代理
                   @Override
                   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                       System.out.println("开始事务2");
                       //执行目标对象方法
                       Object returnValue = method.invoke(target, args);
                       System.out.println("提交事务2");
                       return returnValue;
                   }
               }
       );
   }

}
```
5. 测试类
```java
public class App {
   public static void main(String[] args) {
       // 目标对象
       IUserDao target = new UserDao();
       // 【原始的类型 class cn.itcast.b_dynamic.UserDao】
       System.out.println(target.getClass());

       // 给目标对象，创建代理对象
       IUserDao proxy = (IUserDao) new ProxyFactory(target).getProxyInstance();
       // class $Proxy0   内存中动态生成的代理对象
       System.out.println(proxy.getClass());

       // 执行方法   【代理对象】
       proxy.save();
   }
}
```




>参考地址:https://www.javazhiyin.com/173.html

#### CGlib代理(子类代理)
1. 优点:
适用于要代理的业务类没有实现接口的情况,在内存中构建一个子类从而扩展目标类的功能,因此代理的目标类不能使final的
2. 缺点

3. 工厂
```java
public class ProxyFactory implements MethodInterceptor{
   //维护目标对象
   private Object target;

   public ProxyFactory(Object target) {
       this.target = target;
   }

   //给目标对象创建一个代理对象
   public Object getProxyInstance(){
       //1.工具类
       Enhancer en = new Enhancer();
       //2.设置父类
       en.setSuperclass(target.getClass());
       //3.设置回调函数
       en.setCallback(this);
       //4.创建子类(代理对象)
       return en.create();
   }

   @Override
   public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
       System.out.println("开始事务...");
       //执行目标对象的方法
       Object returnValue = method.invoke(target, args);
       System.out.println("提交事务...");
       return returnValue;
   }
}
```
4. 测试类
```java
public class App {
   public void test(){
       //目标对象
       UserDao target = new UserDao();
       //代理对象
       UserDao proxy = (UserDao)new ProxyFactory(target).getProxyInstance();
       //执行代理对象的方法
       proxy.save();
   }
}
```



## 代理模式的应用
比如AOP，比如过滤器、拦截器等。
在我们平时使用的框架中，像servlet的filter、包括spring提供的aop以及struts2的拦截器都使用了动态代理功能。我们日常看到的mybatis分页插件，以及日志拦截、事务拦截、权限拦截等.
1. 在Spring的AOP编程中
	* 如果目标类实现了接口,使用JDK动态代理
	* 如果没有实现接口,使用CGlib动态代理

















