---
title: 数据库
categories:
  - 数据库
tags:
  - 优化
  - 读写分离
  - 主备方案
date: 2018-07-07 20:48:56
---
 数据库相关知识
 <!-- more -->



# 分库分表
{% post_link 分库分表%}

# 读写分离
>参考地址:https://blog.csdn.net/justdb/article/details/17331569



## 概念
1. what
读写分离，基本的原理是让主数据库处理事务性增、改、删操作（INSERT、UPDATE、DELETE），而从数据库处理SELECT查询操作。数据库复制被用来把事务性操作导致的变更同步到集群中的从数据库。
2. why
所以读写分离，解决的是，数据库的写入，影响了查询的效率。
3. when
数据库不一定要读写分离，**如果程序使用数据库较多时，而更新少，查询多的情况下会考虑使用，利用数据库 主从同步 。可以减少数据库压力，提高性能。**当然，数据库也有其它优化方案。memcache 或是 表折分，或是搜索引擎。都是解决方法。
{% asset_img 读写分离.png 读写分离%}

## 提高性能的原因
1. 物理服务器增加，负荷增加
2. 主从只负责各自的写和读，极大程度的缓解X锁和S锁争用
3. 从库可配置myisam引擎，提升查询性能以及节约系统开销
4. 从库同步主库的数据和主库直接写还是有区别的，通过主库发送来的binlog恢复数据，但是，最重要区别在于主库向从库发送binlog是异步的，从库恢复数据也是异步的
5. 读写分离适用与读远大于写的场景，如果只有一台服务器，当select很多时，update和delete会被这些select访问中的数据堵塞，等待select结束，并发性能不高。 对于写和读比例相近的应用，应该部署双主相互复制
6. 可以在从库启动是增加一些参数来提高其读的性能，例如--skip-innodb、--skip-bdb、--low-priority-updates以及--delay-key-write=ALL。当然这些设置也是需要根据具体业务需求来定得，不一定能用上
7. 分摊读取。假如我们有1主3从，不考虑上述1中提到的从库单方面设置，假设现在1分钟内有10条写入，150条读取。那么，1主3从相当于共计40条写入，而读取总数没变，因此平均下来每台服务器承担了10条写入和50条读取（主库不承担读取操作）。因此，虽然写入没变，但是读取大大分摊了，提高了系统性能。另外，当读取被分摊后，又间接提高了写入的性能。所以，总体性能提高了，说白了就是拿机器和带宽换性能。MySQL官方文档中有相关演算公式：官方文档 见6.9FAQ之“MySQL复制能够何时和多大程度提高系统性能”
8. MySQL复制另外一大功能是增加冗余，提高可用性，当一台数据库服务器宕机后能通过调整另外一台从库来以最快的速度恢复服务，因此不能光看性能，也就是说1主1从也是可以的。

# Mysql主从同步方案(实现读写分离)
>参考地址: https://www.jianshu.com/p/ab704b437ebd

## 实现
基于binlog实现
>参考地址:https://jaminzhang.github.io/mysql/MySQL-Master-Slave-Replication-Principle/

## 流程
1. master要开启binlog功能
2. slave上执行`start slave`,然后slave的IO线程会向master请求其binlog中指定位置之后的内容
3. master上的IO线程收到请求之后会将binlog中指定位置之后的日志信息返回,同时包含新的binlog文件名和下一个指定的更新位置
4. slave的IO线程接受到日志数据之后,将数据添加到本地的中继日志(relay log)的末端,并记录新的binlog文件名和下一个更新位置,
5. 当slave的SQL线程检测到中继日志中有新内容的时候,将日志内容解析成SQL执行
{% asset_img mysql主从复制.jpeg %}

## 主从切换的注意点
master故障是binlog没有及时传给slave,各个slave数据不一致
1. 确保binlog全部传到slave
  1. 半同步,事务提交之后只有binlog传到slave之后才算结束,影响性能
  2. 通过os层文件系统将binlog保存到备用机
2. 如果允许数据丢失
在salve中选择一个binlog最新的变成master,原master恢复后,将数据回退

# 慢查询优化:
## 分析sql方法
参考地址:https://blog.csdn.net/u012990533/article/details/45643509
`explain select * from table where table.id = 1 `
运行上面的sql语句后你会看到，下面的表头信息：
`table | type | possible_keys | key | key_len | ref | rows | Extra`
1. table 
显示这一行的数据是关于哪张表的
2. type 
这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、indexhe和ALL
说明：不同连接类型的解释（按照效率高低的顺序排序）
    * system：表只有一行：system表。这是const连接类型的特殊情况。
    * const ：表中的一个记录的最大值能够匹配这个查询（索引可以是主键或惟一索引）。因为只有一行，这个值实际就是常数，因为MYSQL先读这个值然后把它当做常数来对待。
    * eq_ref：在连接中，MYSQL在查询时，从前面的表中，对每一个记录的联合都从表中读取一个记录，它在查询使用了索引为主键或惟一键的全部时使用。
    * ref：这个连接类型只有在查询使用了不是惟一或主键的键或者是这些类型的部分（比如，利用最左边前缀）时发生。对于之前的表的每一个行联合，全部记录都将从表中读出。这个类型严重依赖于根据索引匹配的记录多少—越少越好。
    * range：这个连接类型使用索引返回一个范围中的行，比如使用>或<查找东西时发生的情况。
    * index：这个连接类型对前面的表中的每一个记录联合进行完全扫描（比ALL更好，因为索引一般小于表数据）。
    * ALL：这个连接类型对于前面的每一个记录联合进行完全扫描，这一般比较糟糕，应该尽量避免。
3. possible_keys 
显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句
4. key 
实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MYSQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MYSQL忽略索引
5. key_len 
使用的索引的长度。在不损失精确性的情况下，长度越短越好
6. ref 
显示索引的哪一列被使用了，如果可能的话，是一个常数
7. rows 
MYSQL认为必须检查的用来返回请求数据的行数
8. Extra 
关于MYSQL如何解析查询的额外信息。将在表4.3中讨论，但这里可以看到的坏的例子是Using temporary和Using filesort，意思MYSQL根本不能使用索引，结果是检索会很慢
说明：extra列返回的描述的意义
    * Distinct ：一旦mysql找到了与行相联合匹配的行，就不再搜索了。
    * Not exists ：mysql优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，就不再搜索了。
    * Range checked for each Record（index map:#） ：没有找到理想的索引，因此对从前面表中来的每一个行组合，mysql检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一。
    * Using filesort ：看到这个的时候，查询就需要优化了。mysql需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行。
    * Using index ：列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候。
    * Using temporary ：看到这个的时候，查询需要优化了。这里，mysql需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上。
    * Where used ：使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index，这就会发生，或者是查询有问题。

## 优化方法
参考地址:https://tech.meituan.com/mysql-index.html
1. 先运行看看是否真的很慢，注意设置SQL_NO_CACHE
1. where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高
2. explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）比如`explain select * from test1 where id=1;`
3. order by limit 形式的sql语句让排序的表优先查
4. 了解业务方使用场景
5. 加索引时参照建索引的几大原则
6. 观察结果，不符合预期继续从0分析

# 完整的对象访问名称
## Oracle
参考地址:https://blog.csdn.net/KimSoft/article/details/4627520
