---
title: 数据库
categories:
  - 笔记
tags:
  - 数据库
date: 2018-07-07 20:48:56
---
 数据库相关知识
 <!-- more -->

# sql基础语法
## group by

# sql执行顺序
{% asset_img sql执行顺序.png sql执行顺序%}

# 索引
## 优缺点
1. 优点
可以加快查询速度
2. 缺点
占空间

## innodb
### 行锁原理
### 与mylsam的区别

## 不同查询条件下的命中情况

## 聚集索引
## 加速原理
### B+树的介绍
参考地址:http://blog.csdn.net/guoziqing506/article/details/64122287
与b树相比较
1. b+树的磁盘读写代价更低,因为b+树的内部节点并没有指向关键字的指针的具体信息
2. 查询效率更加稳定,因为内部节点并不是指向最终文件内容的节点,而是指向关键字的节点,所以每一次查询都必须从根节点到叶子结点,长度相同
3. b树在解决io效率的时候并没有解决元素遍历效率低下的问题,而b+树只需要遍历叶子节点就能解决对所有关键字的查询,对于数据库中经常使用的范围查询性能更高

### 创建索引的原则:
1. 最左前缀匹配原则
2. =和in可以乱序,mysql会自动优化
3. 尽量选择区分度高的列来做索引
4. 索引列不能参与计算
5. 尽量扩展索引而不是新建


# 分库分表

# 读写分离
## 概念

# Mysql主备方案

# 数据库事务,可重复读
数据库事务:银行转账的例子
## 数据库的隔离级别:
1. read UNcommited(未提交读) 允许读取未提交的数据:最低级别,可以使用排他血写锁实现,可以读取到已经修改但是未提交的数据
可能出现各种读
2. read committed(提交读) 允许不可重复读:可以使用共享读锁(读取完该行就释放)和排它写锁来实现,对于同一数据项,前面读取的数据和后来读取的数据可能不一样
可能出现不可重复读和幻读
3. repeated read(可重复读) 可重复读如何实现:可以通过共享读锁(直到事务结束才释放)和排它写锁来实现.数据库进行读事务的时候就会禁止其他的写事务,进行写事务的时候就会禁止其他任何事务写操作
可能出现幻读,因为其他事务虽然不能修改该行数据,但是可以新增数据行,
4. serializable(可序列化) 可序列化:最高级别,事务串行

## 由于低级别隔离性产生的问题:
1. 脏读:事务1删除了表中唯一数据a,但是没有提交,此时事务2查询表返回为空,这就是脏读,然后准备插入数据a,这时候事务1发生回滚,表中又有了数据a,事务2插入错误
2. 幻读:重点在插入了新数据,事务1查询返回结果为空表,此时事务2插入新数据a并提交,然后事务1也插入数据a,此时报错,刚刚明明是空表,现在却提示数据冲突.
3. 不可重复读:重点在于修改了数据,事务1读取到数据a,此时事务2将数据a修改成数据b,然后事务1再次读取数据a时就变成了数据b

## 产生死锁的可能:
1. 事务1获取数据a的锁,想要访问数据b,但是此时数据b被事务2锁定,而事务2希望访问数据a,陷入相互等待的局面.
解决的方式就是从根源上避免这种情况的出现,就是修改程序逻辑,避免出现环,可以一开始就将所有要用到的资源锁定
还有就是采用抢占和回滚机制,根据时间戳来判断事务应该回滚还是等待

## 并发控制机制
1. 悲观锁
就是之前的共享锁和互斥锁(排它锁)
2. 乐观锁(其实是一种并发控制思想,基于时间戳)
3. 多版本并发控制(MVCC)
就是为数据的每一个写操作创建版本,在进行读操作的时候就会在有限多的版本中选择最合适的返回


# 慢查询优化:
## 分析sql方法
参考地址:https://blog.csdn.net/u012990533/article/details/45643509
`explain select * from table where table.id = 1 `
运行上面的sql语句后你会看到，下面的表头信息：
`table | type | possible_keys | key | key_len | ref | rows | Extra`
1. table 
显示这一行的数据是关于哪张表的
2. type 
这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、indexhe和ALL
说明：不同连接类型的解释（按照效率高低的顺序排序）
    * system：表只有一行：system表。这是const连接类型的特殊情况。
    * const ：表中的一个记录的最大值能够匹配这个查询（索引可以是主键或惟一索引）。因为只有一行，这个值实际就是常数，因为MYSQL先读这个值然后把它当做常数来对待。
    * eq_ref：在连接中，MYSQL在查询时，从前面的表中，对每一个记录的联合都从表中读取一个记录，它在查询使用了索引为主键或惟一键的全部时使用。
    * ref：这个连接类型只有在查询使用了不是惟一或主键的键或者是这些类型的部分（比如，利用最左边前缀）时发生。对于之前的表的每一个行联合，全部记录都将从表中读出。这个类型严重依赖于根据索引匹配的记录多少—越少越好。
    * range：这个连接类型使用索引返回一个范围中的行，比如使用>或<查找东西时发生的情况。
    * index：这个连接类型对前面的表中的每一个记录联合进行完全扫描（比ALL更好，因为索引一般小于表数据）。
    * ALL：这个连接类型对于前面的每一个记录联合进行完全扫描，这一般比较糟糕，应该尽量避免。
3. possible_keys 
显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句
4. key 
实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MYSQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MYSQL忽略索引
5. key_len 
使用的索引的长度。在不损失精确性的情况下，长度越短越好
6. ref 
显示索引的哪一列被使用了，如果可能的话，是一个常数
7. rows 
MYSQL认为必须检查的用来返回请求数据的行数
8. Extra 
关于MYSQL如何解析查询的额外信息。将在表4.3中讨论，但这里可以看到的坏的例子是Using temporary和Using filesort，意思MYSQL根本不能使用索引，结果是检索会很慢
说明：extra列返回的描述的意义
    * Distinct ：一旦mysql找到了与行相联合匹配的行，就不再搜索了。
    * Not exists ：mysql优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，就不再搜索了。
    * Range checked for each Record（index map:#） ：没有找到理想的索引，因此对从前面表中来的每一个行组合，mysql检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一。
    * Using filesort ：看到这个的时候，查询就需要优化了。mysql需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行。
    * Using index ：列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候。
    * Using temporary ：看到这个的时候，查询需要优化了。这里，mysql需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上。
    * Where used ：使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index，这就会发生，或者是查询有问题。

## 优化方法
参考地址:https://tech.meituan.com/mysql-index.html
1. 先运行看看是否真的很慢，注意设置SQL_NO_CACHE
1. where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高
2. explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）比如`explain select * from test1 where id=1;`
3. order by limit 形式的sql语句让排序的表优先查
4. 了解业务方使用场景
5. 加索引时参照建索引的几大原则
6. 观察结果，不符合预期继续从0分析

# 完整的对象访问名称
## Oracle
参考地址:https://blog.csdn.net/KimSoft/article/details/4627520
