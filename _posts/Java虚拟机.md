---
title: Java虚拟机
categories:
  - 笔记
tags:
  - Java
  - 虚拟机
  - JVM
  - 线程安全
date: 2018-07-08 16:12:32
---
 JVM相关知识
 <!-- more -->

# 相关概念
## 吞吐量
吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。


## 内核态
### 是什么
### 保护模式

## 类加载过程
{% asset_link JVM类加载机制.md JVM类加载机制%}
1. 加载
2. 验证
3. 准备
4. 解析
5. 初始化


---
## 内存管理
### StackOverflow
启动一个新的线程的时候,虚拟机会分配一个栈,java栈以栈帧的方式保存线程运行状态,然后线程调用方法的时候,虚拟机就会压入新的栈帧,只要方法没有返回,栈帧就会存在,当栈帧太多就会导致溢出.
### OutOfMemory
1. 栈内存溢出
	就是启动的线程太多,没有足够的空间分配java栈了.一个线程的java栈大小由-Xss参数设置
2. 堆内存溢出
	java堆中存放对象实例的空间不足,通过-Xmx设置最大值.
3. 方法区和运行时常量池溢出
	`-XX:permSize=10M -XX:MaxPermSize=10M`
4. 本机直接内存溢出
	`-XX:MaxDirectMemorySize`

### 内存模型
根据某种特定的操作协议,对特定的内存或者高速缓存进行读写访问的过程抽象
1. 内存模型
为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。
2. java内存模型
Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。
3. 8中原子操作:
	* lock:作用于主内存的变量,将一个变量标记为一条线程独占
	* unlock:主内存,施放线程独占的变量
	* read:主内存,将变量值从主内存传输到线程的工作内存,之后要使用load操作
	* load:作用于工作内存,将从主内存中read得到的变量值放入工作内存的变量副本中
	* use:工作内存,将工作内存中一个变量的值传递给执行引擎
	* assign:工作内存,将从执行引擎接收到的值赋值给工作内存中的变量
	* store:工作内存,将工作内存中的变量值从工作内存传送到主内存,供之后的write操作使用 
	* write:主内存,包store操作从工作内存中取得的值放入主内存的变量中



## 垃圾回收(GC)
分为堆(heap)和非堆(non-heap)
简单说,堆就是给开发人员使用的代码可及的存放类实例和数组的内存区域;非堆就是除了堆之外的留给JVM自己使用的内存区域.
### 方法区的变动
1. (JDK1.8)移除了永久带,类元信息被放到metaSpace(本地化的内存?),一定程度上解决原来运行时加载大量类信息而引起的Full GC的问题,如反射,动态代理
2. 将常量池(JDK1.7中就移了)和静态变量放到了java堆中

### 运行时数据区
{% asset_img java虚拟机运行时数据区.png java虚拟机运行时数据区%}
1. 程序计数器：线程私有。是一块较小的内存，是当前线程所执行的字节码的行号指示器。是Java虚拟机规范中唯一没有规定OOM（OutOfMemoryError）的区域。
2. Java栈：线程私有。生命周期和线程相同。是Java方法执行的内存模型。执行每个方法都会创建一个栈帧，用于存储局部变量和操作数（对象引用）。局部变量所需要的内存空间大小在编译期间完成分配。所以栈帧的大小不会改变。存在两种异常情况：若线程请求深度大于栈的深度，抛StackOverflowError。若栈在动态扩展时无法请求足够内存，抛OOM。
3. Java堆：所有线程共享。虚拟机启动时创建。存放对象实力和数组。所占内存最大。分为新生代（Young区），老年代（Old区）。新生代分Eden区，Servior区。Servior区又分为From space区和To Space区。Eden区和Servior区的内存比为8:1。 当扩展内存大于可用内存，抛OOM。
4. 方法区：所有线程共享。用于存储已被虚拟机加载的类信息、常量、静态变量等数据。又称为非堆（Non–Heap）。方法区又称“永久代”(JDK1.8中已经移除)。GC很少在这个区域进行，但不代表不会回收。这个区域回收目标主要是针对常量池的回收和对类型的卸载。当内存申请大于实际可用内存，抛OOM。
5. 本地方法栈：线程私有。与Java栈类似，但是不是为Java方法（字节码）服务，而是为本地非Java方法服务。也会抛StackOverflowError和OOM。

### 堆内存结构
{% asset_img 堆空间.jpg 堆空间%}
JVM堆内存分为2块：Permanent Space 和 Heap Space
* Permanent 即 持久代（Permanent Generation），主要存放的是Java类定义信息，与垃圾收集器要收集的Java对象关系不大。
* Heap = { Old + NEW(Eden, from, to) }，Old 即 年老代（Old Generation），New 即 年轻代（Young Generation）。年老代和年轻代的划分对垃圾收集影响比较大。
	1. 年轻代
	所有新生成的对象首先都是放在年轻代。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代一般分3个区，1个Eden区，2个Survivor区（from 和 to）。
	大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当一个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当另一个Survivor区也满了的时候，从前一个Survivor区复制过来的并且此时还存活的对象，将可能被复制到年老代。
	2个Survivor区是对称的，没有先后关系，所以同一个Survivor区中可能同时存在从Eden区复制过来对象，和从另一个Survivor区复制过来的对象；而复制到年老区的只有从另一个Survivor区过来的对象。而且，因为需要交换的原因，Survivor区至少有一个是空的。特殊的情况下，根据程序需要，Survivor区是可以配置为多个的（多于2个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。
	针对年轻代的垃圾回收即 Young GC。
	2. 年老代
	在年轻代中经历了N次（可配置）垃圾回收后仍然存活的对象，就会被复制到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。
	针对年老代的垃圾回收即 Full GC。
	3. 持久代
	用于存放静态类型数据，如 Java Class, Method 等。持久代对垃圾回收没有显著影响。但是有些应用可能动态生成或调用一些Class，例如 Hibernate CGLib 等，在这种时候往往需要设置一个比较大的持久代空间来存放这些运行过程中动态增加的类型。



### 什么时候回收
触发GC的条件,JVM卸载类的判断条件:
根据Eden区和From Space区的内存大小来决定。当内存大小不足时，则会启动GC线程并停止应用线程。
1. Minor GC(新生代GC)
当Eden区满时，触发
指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。
2. Full GC(老年代GC)
也叫Major GC,速度一般会比Minor GC慢10倍以上。
	1. 调用System.gc时，系统建议执行Full GC，但是不必然执行
	2. 老年代空间不足
	3. 1.7之前的方法区(永久带)空间不足
	4. 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
	5. 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

### 回收对象 
通过可达性分析法无法搜索到的对象和可以搜索到的对象。对于搜索不到的方法进行标记。
1. 该类的所有实例都已经被回收,也就是java堆中不存在该类的任何实例
2. 加载该类的ClassLoader已经被回收
3. 该类对应的java.lang.Class对象没有在任何地方呗引用,无法通过反射在任何地方访问该类的方法

### 怎么回收
对于可以搜索到的对象进行复制操作，对于搜索不到的对象，调用finalize()方法进行释放。当GC线程启动时，会通过可达性分析法把Eden区和From Space区的存活对象复制到To Space区，然后把Eden Space和From Space区的对象释放掉。当GC轮训扫描To Space区一定次数后，把依然存活的对象复制到老年代，然后释放To Space区的对象。

### 引用的分类
1. 强引用
	类似`Object obj = new Object()`这类,只要强引用在,永远不会被回收
2. 软引用
	有用但是非必须的,只有内存不够的时候会被回收,如果回收之后还是不够才会抛出内存溢出异常
3. 弱引用
	只能存活到下一次垃圾回收
4. 虚引用
	唯一目的就是在一个关联了虚引用的对象被回收的时候收到系统通知

### 判断对象是否存活的方法
1. 引用计数法
	当对象被引用的时候计数加一,不用的时候减一,缺点是无法解决对象之间相互循环引用的问题,比如两个对象中的成员变量相互引用的时候
2. 可达性分析算法
	当一个对象到GC Roots没有任何引用链相连的时候,就是该对象不可用
	GC Roots包括:
		1. 虚拟机栈(栈帧中的本地变量表)中的引用对象
		2. 方法区中的类的静态引用属性
		3. 方法区中的常量引用的对象
		4. 本地方法栈中JNI(即一般说的Native方法)引用的对象

### 回收方法区(HotSpot中的永久带)
回收性价比比较低,主要回收弃用常量和无用的类
1. 判断弃用常量
	比如字面量"abc",当没有String对象叫"abc"的时候
2. 判断无用的类(同时满足以下三个条件)
	1. 当java堆中没有该类的实例
	2. 加载该类的ClassLoader被回收
	3. 该类的java.lang.Class对象没有在任何地方被引用,也就是无法在任何地方通过反射访问该类的方法

### 垃圾回收算法
1. 标记清除算法
	不足:标记和清除的效率不高,然后就是清除之后会产生大量不连续的内存碎片
2. 复制算法
	直接将内存一分为二,当其中一块内存用完了,将其中还存活的对象复制到另一块内存上,比较浪费空间.
3. 复制收集算法(回收新生代)
	将内存分为一块Eden空间和两块Survivor空间,8:1:1,回收时将Eden和Survivor中还存活的对象复制到另一块Survivor空间中,如果Survivor空间内存不够,就需要用到老年代
4. 标记整理算法(回收老年代)
5. 分代收集算法
	一般将java堆分成新生代和老年代,再使用合适的回收算法

### 并行和并发
并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行。而垃圾收集程序运行在另一个CPU上。	

### 垃圾收集器(书上列举了七种)
>参考地址:https://crowhawk.github.io/2017/08/15/jvm_3/

{% asset_img 垃圾收集器.jpg 垃圾收集器%}

#### 新生代收集器
1. Serial收集器
	1. 采用**复制算法**的新生代收集器。
	2. 是一个单线程收集器，只会使用一个CPU或一条收集线程去完成垃圾收集工作，在进行垃圾收集时，必须暂停其他所有的工作线程，直至Serial收集器收集结束为止（“Stop The World”）。
	3. 这项工作是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说是难以接受的。
下图展示了Serial 收集器（老年代采用Serial Old收集器）的运行过程：
{% asset_img Serial收集器运行过程.png Serial收集器运行过程%}
依然是HotSpot虚拟机运行在Client模式下的默认的新生代收集器。它也有着优于其他收集器的地方：简单而高效（与其他收集器的单线程相比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得更高的单线程收集效率。
在用户的桌面应用场景中，分配给虚拟机管理的内存一般不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本不会再大了），停顿时间完全可以控制在几十毫秒最多一百毫秒以内，只要不频繁发生，这点停顿时间可以接收。所以，Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择。

2. ParNew收集器
	1. ParNew收集器就是Serial收集器的多线程版本，它也是一个新生代收集器。
	2. 除了使用多线程进行垃圾收集外，其余行为包括Serial收集器可用的所有控制参数、收集算法（复制算法）、Stop The World、对象分配规则、回收策略等与Serial收集器完全相同，两者共用了相当多的代码。
ParNew收集器的工作过程如下图（老年代采用Serial Old收集器）：
{% asset_img ParNew收集器的工作过程.png ParNew收集器的工作过程%}
ParNew收集器除了使用多线程收集外，其他与Serial收集器相比并无太多创新之处，但它却是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关的重要原因是，**除了Serial收集器外，目前只有它能和CMS收集器（Concurrent Mark Sweep）配合工作。**
ParNew 收集器在单CPU的环境中绝对不会有比Serial收集器有更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证可以超越。在多CPU环境下，随着CPU的数量增加，它对于GC时系统资源的有效利用是很有好处的。它默认开启的收集线程数与CPU的数量相同，**在CPU非常多的情况下可使用-XX:ParallerGCThreads参数设置。**

3. Parallel Scavenge 收集器 
	1. 并行的多线程新生代收集器，它也使用复制算法。
	2. CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，**而Parallel Scavenge收集器的目标是达到一个可控制的吞吐量（Throughput）。**
Parallel Scavenge收集器除了会显而易见地提供可以精确控制吞吐量的参数，**还提供了一个参数-XX:+UseAdaptiveSizePolicy，**这是一个开关参数，打开参数后，就不需要手工指定新生代的大小（-Xmn）、Eden和Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为**GC自适应的调节策略（GC Ergonomics）**。自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。
另外值得注意的一点是，Parallel Scavenge收集器无法与CMS收集器配合使用，所以在JDK 1.6推出Parallel Old之前，如果新生代选择Parallel Scavenge收集器，老年代只有Serial Old收集器能与之配合使用。

#### 年老代收集器
1. Serial Old收集器
是Serial收集器的老年代版本，它同样是一个**单线程收集器，使用“标记-整理”（Mark-Compact）算法。**
此收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，它还有两大用途：
	1. 在JDK1.5 以及之前版本（Parallel Old诞生以前）中与Parallel Scavenge收集器搭配使用。
	2. 作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。
工作流程见新生代收集器Serial收集器.

2. Parallel Old收集器
	1. 是Parallel Scavenge收集器的老年代版本，使用**多线程和“标记-整理”算法。**
	2. 在JDK 1.6中才开始提供的
	在此之前，如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old以外别无选择，所以在Parallel Old诞生以后，“吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。Parallel Old收集器的工作流程与Parallel Scavenge相同
Parallel Scavenge/Parallel Old收集器配合使用的流程图：
{% asset_img ParallelScavengeParallelOld收集器配合使用流程图.png ParallelScavenge/ParallelOld收集器配合使用流程图%}

3. CMS收集器(Concurrent Mark Sweep)
	1. 是一种**以获取最短回收停顿时间为目标**的收集器，它非常符合那些集中在互联网站或者B/S系统的服务端上的Java应用，这些应用都非常重视服务的响应速度。
	2. **从名字上（“Mark Sweep”）就可以看出它是基于“标记-清除”算法实现的。**
	CMS收集器工作的整个流程分为以下4个步骤：
		1. 初始标记（CMS initial mark）：
		仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要“Stop The World”。
		2. 并发标记（CMS concurrent mark）：
		进行GC Roots Tracing的过程，在整个过程中耗时最长,查找初始标记中找到的对象相关联的存活对象
		3. 重新标记（CMS remark）：
		为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。此阶段也需要“Stop The World”。
		4. 并发清除（CMS concurrent sweep）
由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。通过下图可以比较清楚地看到CMS收集器的运作步骤中并发和需要停顿的时间:
{% asset_img CMS收集器流程.png CMS收集器流程 %}
优点:并发收集、低停顿
缺点:
	* 对CPU资源非常敏感 
	其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是（CPU数量+3）/4，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个时（比如2个），CMS对用户程序的影响就可能变得很大，如果本来CPU负载就比较大，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，其实也让人无法接受。
	* 无法处理浮动垃圾（Floating Garbage） 
	可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生。这一部分垃圾出现在标记过程之后，CMS无法再当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就被称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。
	* 标记-清除算法导致的空间碎片 
	CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象。
4. G1收集器(Garbage-First)
	1. G1收集器是当今收集器技术发展最前沿的成果之一，它是一款面向服务端应用的垃圾收集器，HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK 1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点：
		* 并行与并发 
		G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短“Stop The World”停顿时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。
		* 分代收集 
		与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同方式去处理新创建的对象和已存活一段时间、熬过多次GC的旧对象来获取更好的收集效果。
		* 空间整合 
		G1从整体来看是基于“标记-整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的。这意味着G1运行期间不会产生内存空间碎片，收集后能提供规整的可用内存。此特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。
		* 可预测的停顿 
		这是G1相对CMS的一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了降低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在GC上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。
	2. 横跨整个堆内存
	在G1之前的其他收集器进行收集的范围都是整个新生代或者老生代，而G1不再是这样。G1在使用时，Java堆的内存布局与其他收集器有很大区别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，而都是一部分Region（不需要连续）的集合。每个region被标记成E,S,O,H,其中H代表Humongous,用来分配 大对象(当对象实例大小超过Region大小的一半)
{% asset_img G1回收器的内存划分.png G1回收器的内存划分%}
	3. 建立可预测的时间模型
	G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。
	4. 避免全堆扫描——Remembered Set 
	G1把Java堆分为多个Region，就是“化整为零”。但是Region不可能是孤立的，一个对象分配在某个Region中，可以与整个Java堆任意的对象发生引用关系。在做可达性分析确定对象是否存活的时候，需要扫描整个Java堆才能保证准确性，这显然是对GC效率的极大伤害。
	为了避免全堆扫描的发生，虚拟机为G1中每个Region维护了一个与之对应的Remembered Set。虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。
	5. GC的类型
		* young gc 
		当所有的eden region填满,会回收存活对象到survivor region,
		* mixed gc 
		当young region到了一定的比例,会回收整个young region以及部分的old region 
		* full gc 
		当mixed gc来不及,导致old region被填满,则会触发,就是serial old的单线程回收,要尽量避免
	6. G1收集器运作的步骤
	如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤：
		* 初始标记（Initial Marking） 
		仅仅只是标记一下GC Roots 能直接关联到的对象，并且修改TAMS（Nest Top Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可以的Region中创建对象，此阶段需要停顿线程，但耗时很短。
		* 并发标记（Concurrent Marking） 
		从GC Root 开始对堆中对象进行可达性分析，找到存活对象，此阶段耗时较长，但可与用户程序并发执行。
		* 最终标记（Final Marking） 
		为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。
		* 筛选回收（Live Data Counting and Evacuation） 
		首先对各个Region中的回收价值和成本进行排序，根据用户所期望的GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。
通过下图可以比较清楚地看到G1收集器的运作步骤中并发和需要停顿的阶段（Safepoint处）：
{% asset_img G1收集器流程.png G1收集器 %}

### 垃圾收集器总结
{% asset_img 垃圾收集器总结.png 垃圾收集器总结%}



## JVM性能调优的大致步骤
参考地址:https://blog.csdn.net/rickyit/article/details/53895060
参考地址(强烈推荐):https://blog.csdn.net/kthq/article/details/8618052
1. 年轻代大小选择
	响应时间优先的应用 ：尽可能设大，直到接近系统的最低响应时间限制 （根据实际情况选择）。在此种情况下，年轻代收集发生的频率也是最小的。同时，减少到达年老代的对象。
	吞吐量优先的应用 ：尽可能的设置大，可能到达Gbit的程度。因为对响应时间没有要求，垃圾收集可以并行进行，一般适合8CPU以上的应用。
2. 年老代大小选择
	1. 响应时间优先的应用 ：
	年老代使用并发收集器，所以其大小需要小心设置，一般要考虑并发会话率 和会话持续时间 等一些参数。如果堆设置小了，可以会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式；如果堆大了，则需要较长的收集时间。最优化的方案，一般需要参考以下数据获得：
		* 并发垃圾收集信息
		* 持久代并发收集次数
		* 传统GC信息
		* 花在年轻代和年老代回收上的时间比例
	减少年轻代和年老代花费的时间，一般会提高应用的效率
	2. 吞吐量优先的应用 ：
	一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代。原因是，这样可以尽可能回收掉大部分短期对象，减少中期的对象，而年老代尽存放长期存活对象。
3. 较小堆引起的碎片问题
	因为年老代的并发收集器使用标记、清除算法，所以不会对堆进行压缩。当收集器回收时，他会把相邻的空间进行合并，这样可以分配给较大的对象。但是，当堆空间较小时，运行一段时间以后，就会出现“碎片”，如果并发收集器找不到足够的空间，那么并发收集器将会停止，然后使用传统的标记、清除方式进行回收。如果出现“碎片”，可能需要进行如下配置：
		-XX:+UseCMSCompactAtFullCollection ：使用并发收集器时，开启对年老代的压缩。
		-XX:CMSFullGCsBeforeCompaction=0 ：上面配置开启的情况下，这里设置多少次Full GC后，对年老代进行压缩

* 回收器选择
JVM给了三种选择：*串行收集器*、*并行收集器*、*并发收集器* ，但是串行收集器只适用于小数据量的情况，所以这里的选择主要针对并行收集器和并发收集器。默认情况下，JDK5.0以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0以后，JVM会根据当前系统配置进行判断。
	1. 吞吐量优先的 并行收集器
	如上文所述，并行收集器主要以到达一定的吞吐量为目标，适用于科学技术和后台处理等。
	典型配置 ：`java -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20`
	-XX:+UseParallelGC ：选择垃圾收集器为并行收集器。 此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。
	-XX:ParallelGCThreads=20 ：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。
	java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20 -XX:+UseParallelOldGC
	-XX:+UseParallelOldGC ：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集。
	java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100
	-XX:MaxGCPauseMillis=100 : 设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。
	java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100 -XX:+UseAdaptiveSizePolicy
	-XX:+UseAdaptiveSizePolicy ：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。
	2. 响应时间优先的 并发收集器
	如上文所述，并发收集器主要是保证系统的响应时间，减少垃圾收集时的停顿时间。适用于应用服务器、电信领域等。
	典型配置 ：`java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC`
	-XX:+UseConcMarkSweepGC ：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。
	-XX:+UseParNewGC :设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。
	java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection
	-XX:CMSFullGCsBeforeCompaction ：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。
	-XX:+UseCMSCompactAtFullCollection ：打开对年老代的压缩。可能会影响性能，但是可以消除碎片

* 堆大小的典型设置：
        1. `java -Xmx3550m -Xms3550m -Xmn2g -Xss128k`
```
-Xmx3550m ：
设置JVM最大可用内存为3550M。
-Xms3550m ：
设置JVM初始内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。
-Xmn2g ：
设置年轻代大小为2G。整个堆大小 = 年轻代大小 + 年老代大小 + 持久代大小 。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。
-Xss128k ：
设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。
```
        2. `java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m`
```
-XX:MaxTenuringThreshold=0
-XX:NewRatio=4 :
设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5
-XX:SurvivorRatio=4 ：
设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6
-XX:MaxPermSize=16m :
设置持久代大小为16m。
-XX:MaxTenuringThreshold=0 ：
设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代 。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间 ，增加在年轻代即被回收的概论。
```


## 逃逸分析
参考地址:http://www.hollischuang.com/archives/2398
类实例和数组不一定都是分配在堆上了
1. 方法逃逸
在方法中创建对象,作为返回值
2. 线程逃逸
在方法中生成对象赋值给类变量,就可能被其他线程访问

### 概念
逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。
```java
public static StringBuffer craeteStringBuffer(String s1, String s2) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    return sb;
}
```
StringBuffer sb是一个方法内部变量，上述代码中直接将sb返回，这样这个StringBuffer有可能被其他方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，称其逃逸到了方法外部。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。
使用逃逸分析，编译器可以对代码做如下优化：
1. 同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。
2. 将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。
3. 分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。
`-XX:+DoEscapeAnalysis ： 表示开启逃逸分析 -XX:-DoEscapeAnalysis ： 表示关闭逃逸分析 从jdk 1.7开始已经默认开始逃逸分析，如需关闭，需要指定-XX:-DoEscapeAnalysis`

### 实验
看以下代码:
```java
public static void main(String[] args) {
    long a1 = System.currentTimeMillis();
    for (int i = 0; i < 1000000; i++) {
        alloc();
    }
    // 查看执行时间
    long a2 = System.currentTimeMillis();
    System.out.println("cost " + (a2 - a1) + " ms");
    // 为了方便查看堆内存中对象个数，线程sleep
    try {
        Thread.sleep(100000);
    } catch (InterruptedException e1) {
        e1.printStackTrace();
    }
}

private static void alloc() {
    User user = new User();
}

static class User {

}
```
1. 关闭JIT编译器逃逸分析
`-Xmx4G -Xms4G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError `
2. 然后在终端中查看堆中的对象数量:100万个
```java
➜  ~ jps
2809 StackAllocTest
2810 Jps
➜  ~ jmap -histo 2809

 num     #instances         #bytes  class name
----------------------------------------------
   1:           524       87282184  [I
   2:       1000000       16000000  StackAllocTest$User
   3:          6806        2093136  [B
   4:          8006        1320872  [C
   5:          4188         100512  java.lang.String
   6:           581          66304  java.lang.Class
```
3. 打开逃逸分析,只有8万多
`-Xmx4G -Xms4G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError `
```java 
➜  ~ jps
709
2858 Launcher
2859 StackAllocTest
2860 Jps
➜  ~ jmap -histo 2859

 num     #instances         #bytes  class name
----------------------------------------------
   1:           524      101944280  [I
   2:          6806        2093136  [B
   3:         83619        1337904  StackAllocTest$User
   4:          8006        1320872  [C
   5:          4188         100512  java.lang.String
   6:           581          66304  java.lang.Class
```



