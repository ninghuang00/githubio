---
title: Java虚拟机
categories:
  - 笔记
tags:
  - Java
  - 虚拟机
  - JVM
  - 线程安全
date: 2018-07-08 16:12:32
---
 JVM相关知识
 <!-- more -->



## 内核态
### 是什么
### 保护模式

## 类加载过程
### class编译
### 加载 
### 执行原理过程

---
## 内存管理
### StackOverflow
启动一个新的线程的时候,虚拟机会分配一个栈,java栈以栈帧的方式保存线程运行状态,然后线程调用方法的时候,虚拟机就会压入新的栈帧,只要方法没有返回,栈帧就会存在,当栈帧太多就会导致溢出.
### OutOfMemory
1. 栈内存溢出
	就是启动的线程太多,没有足够的空间分配java栈了.一个线程的java栈大小由-Xss参数设置
2. 堆内存溢出
	java堆中存放对象实例的空间不足,通过-Xmx设置最大值.
3. 方法区和运行时常量池溢出
	`-XX:permSize=10M -XX:MaxPermSize=10M`
4. 本机直接内存溢出
	`-XX:MaxDirectMemorySize`

### 内存模型
根据某种特定的操作协议,对特定的内存或者高速缓存进行读写访问的过程抽象
8中原子操作:
* lock:作用于主内存的变量,将一个变量标记为一条线程独占
* unlock:主内存,施放线程独占的变量
* read:主内存,将变量值从主内存传输到线程的工作内存,之后要使用load操作
* load:作用于工作内存,将从主内存中read得到的变量值放入工作内存的变量副本中
* use:工作内存,将工作内存中一个变量的值传递给执行引擎
* assign:工作内存,将从执行引擎接收到的值赋值给工作内存中的变量
* store:工作内存,将工作内存中的变量值从工作内存传送到主内存,供之后的write操作使用 
* write:主内存,包store操作从工作内存中取得的值放入主内存的变量中



## 垃圾回收(GC)
### 堆内存结构
JVM堆内存分为2块：Permanent Space 和 Heap Space
* Permanent 即 持久代（Permanent Generation），主要存放的是Java类定义信息，与垃圾收集器要收集的Java对象关系不大。
* Heap = { Old + NEW = {Eden, from, to} }，Old 即 年老代（Old Generation），New 即 年轻代（Young Generation）。年老代和年轻代的划分对垃圾收集影响比较大。
	1. 年轻代
	所有新生成的对象首先都是放在年轻代。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代一般分3个区，1个Eden区，2个Survivor区（from 和 to）。
	大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当一个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当另一个Survivor区也满了的时候，从前一个Survivor区复制过来的并且此时还存活的对象，将可能被复制到年老代。
	2个Survivor区是对称的，没有先后关系，所以同一个Survivor区中可能同时存在从Eden区复制过来对象，和从另一个Survivor区复制过来的对象；而复制到年老区的只有从另一个Survivor区过来的对象。而且，因为需要交换的原因，Survivor区至少有一个是空的。特殊的情况下，根据程序需要，Survivor区是可以配置为多个的（多于2个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。
	针对年轻代的垃圾回收即 Young GC。
	2. 年老代
	在年轻代中经历了N次（可配置）垃圾回收后仍然存活的对象，就会被复制到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。
	针对年老代的垃圾回收即 Full GC。
	3. 持久代
	用于存放静态类型数据，如 Java Class, Method 等。持久代对垃圾回收没有显著影响。但是有些应用可能动态生成或调用一些Class，例如 Hibernate CGLib 等，在这种时候往往需要设置一个比较大的持久代空间来存放这些运行过程中动态增加的类型。



### 什么时候回收
JVM卸载类的判断条件
1. 该类的所有实例都已经被回收,也就是java堆中不存在该类的任何实例
2. 加载该类的ClassLoader已经被回收
3. 该类对应的java.lang.Class对象没有在任何地方呗引用,无法通过反射在任何地方访问该类的方法

### 怎么回收

### 引用的分类
1. 强引用
	类似`Object obj = new Object()`这类,只要强引用在,永远不会被回收
2. 软引用
	有用但是非必须的,只有内存不够的时候会被回收,如果回收之后还是不够才会抛出内存溢出异常
3. 弱引用
	只能存活到下一次垃圾回收
4. 虚引用
	唯一目的就是在一个关联了虚引用的对象被回收的时候收到系统通知

### 判断对象是否存活的方法
1. 引用计数法
	当对象被引用的时候计数加一,不用的时候减一,缺点是无法解决对象之间相互循环引用的问题,比如两个对象中的成员变量相互引用的时候
2. 可达性分析算法
	当一个对象到GC Roots没有任何引用链相连的时候,就是该对象不可用
	GC Roots包括:
		1. 虚拟机栈(栈帧中的本地变量表)中的引用对象
		2. 方法区中的类的静态引用属性
		3. 方法区中的常量引用的对象
		4. 本地方法栈中JNI(即一般说的Native方法)引用的对象

### 回收方法区(HotSpot中的永久带)
回收性价比比较低,主要回收弃用常量和无用的类
1. 判断弃用常量
	比如字面量"abc",当没有String对象叫"abc"的时候
2. 判断无用的类(同时满足以下三个条件)
	1. 当java堆中没有该类的实例
	2. 加载该类的ClassLoader被回收
	3. 该类的java.lang.Class对象没有在任何地方被引用,也就是无法在任何地方通过反射访问该类的方法

### 垃圾回收算法
1. 标记清除算法
	不足:标记和清除的效率不高,然后就是清除之后会产生大量不连续的内存碎片
2. 复制算法
	直接将内存一分为二,当其中一块内存用完了,将其中还存活的对象复制到另一块内存上,比较浪费空间.
3. 复制收集算法(回收新生代)
	将内存分为一块Eden空间和两块Survivor空间,8:1:1,回收时将Eden和Survivor中还存活的对象复制到另一块Survivor空间中,如果Survivor空间内存不够,就需要用到老年代
4. 标记整理算法(回收老年代)
5. 分代收集算法
	一般将java堆分成新生代和老年代,再使用合适的回收算法

### 垃圾收集器(书上列举了七种)
1. Serial收集器
	单线程收集器,垃圾回收时必须暂停其他所有的工作线程
2. ParNew收集器


## 线程安全 
### volatile的使用(有两种语义)
1. 能够保证修饰的变量对所有线程的可见性,当一条线程修改了了这个变量,其他线程可以马上得知.线程A修改了普通变量的值之后需要先回写到主内存之后,新的变量值才能被线程B读取到.但是并不能保证基于volatile变量的运算在并发下是安全的.
	使用volatile进行安全的并发运算的规则
	1. 运算结果不依赖变量的当前值,或者确保只有单一线程修改变量的值
	2. 变量不需要与其他状态变量共同参与不变约束
	比如多线程的累加是不安全的,因为累加不是原子操作;
	比如布尔值的判断可以是安全的,多个线程判断一个flag是true还是false是可以线程安全的.
2. 禁止指令重排序优化,普通变量不能保证普通的赋值操作和代码中的顺序是一致的.
	比如说线程a进行初始化工作,初始化完之后将初始化完成的标志置为true,线程b中根据初始化完成标志开始其他工作,如果线程a,b并发,这个时候就有可能出错,因为指令重排序优化的关系,线程a中的初始化标志的指令可能会提前执行,

### 线程安全的实现方法
1. 互斥同步(阻塞同步)
互斥同步对性能最大的影响就是对阻塞的实现,挂起和恢复线程的操作需要切换到内核态中完成
	1. synchronized
	关键是要分清楚是给类加锁还是给对象实例加锁
	2. java.util.concurrent.ReentrantLock(注意锁的声明要放在需要同步的方法的外面)
	和synchronized基本用法类似,使用lock()和unlock()方法配合try/finally语句块来完成,但是有以下三个特色:
		1. 等待可中断
		2. 可实现公平锁
		3. 锁可以绑定多个条件
2. 非阻塞同步
不断重试
3. 无同步方案
	1. 可重入代码
	可以在代码执行的任何时刻中断去执行其他代码(包括递归调用自己),并且在回来的时候原来的程序不会出现任何错误
	2. 线程本地存储
	将共享数据的代码保证在同一个线程中完成

### 锁 
#### 可重入锁和synchronized
1. 锁的实现:
ReentrantLock是JDK实现的,synchronized是依赖于JVM实现的
2. 性能的区别:
JDK1.6之后(synchronized引入了偏向锁,轻量级锁(自旋锁)之后)synchronized优化的与ReentrantLock性能差不多,在两种方法都可以使用的情况下官方建议使用synchronized,都是试图在用户态就将加锁问题解决,避免进入内核态
3. 功能的区别:
synchronized的使用比较简洁,由编译器保证加锁和施放锁,而ReentrantLock需要手工声明加锁和施放锁,但是ReentrantLock在锁的细粒度和灵活性方面更强
	1. ReentrantLock可以指定公平锁和非公平锁,synchronized只能是非安全锁
	2. ReentrantLock提供了一个Condition类来实现按照满足条件分组唤醒线程,而synchronized只能是随机唤醒一个线程,要么全部唤醒
	3. ReentrantLock提供了一个可以中断等待锁的机制,通过lock.lockInterruptibly()来实现这个机制

#### 锁优化
1. 自旋锁和自适应自旋锁
就是当后一个线程请求锁的时候,不要一请求不到就马上挂起,而是等待一下(前提是物理机器有一个以上的处理器),但不放弃处理器的执行时间,看看持有锁的线程是否会很快释放锁,为了让线程等待,只需要让线程执行一个忙循环(自旋)
2. 锁消除(虚拟机优化) 
虚拟机即时编译器在运行的时候会对一些代码上要求同步但是实际上不会发生数据共享竞争的锁进行消除,根据逃逸分析的数据支持,如果堆上的数据不会逃逸出去从而被其他线程访问到,就可以把他们当做是栈上的数据对待,认为他们是线程私有的,同步加锁自然无需进行,比如说StringBuilder.append()方法.
3. 锁粗化
就是一串连续的零碎操作都对同一个对象加锁,那么就会将加锁同步的范围扩大
4. 轻量级锁
5. 偏向锁

### 线程安全是相对的
(深入理解Java虚拟机P390)
比如说Vector是一个线程安全的集合容器,因为它的add(),get(),size(),remove()方法都是被synchronized修饰过的,但是并不意味着调用这些方法就永远不需要额外的同步手段了,一下代码就有可能会出现ArrayIndexOutOfBoundsException.
```java
public class VectorDemo {
    private static Vector<Integer> vector = new Vector();
    public static void main(String[] args) {
        while (true) {
            for (int i = 0; i<10;i++) {
                vector.add(i);
            }
            Thread removeTask = new Thread(new Runnable() {
                public void run() {
                    for(int i = 0;i < 10; i ++) {
                        vector.remove(i);
                    }
                }
            });
            Thread printTask = new Thread(new Runnable() {
                public void run() {
                    for(int i = 0;i < 10; i ++) {
                        System.out.println(vector.get(i));
                    }
                }
            });
            removeTask.start();
            printTask.start();
            //防止线程过多
            while (Thread.activeCount() > 20) ;
        }
    }
}
```

## JVM性能调优的大致步骤
参考地址:https://blog.csdn.net/rickyit/article/details/53895060
参考地址(强烈推荐):https://blog.csdn.net/kthq/article/details/8618052
1. 年轻代大小选择
	响应时间优先的应用 ：尽可能设大，直到接近系统的最低响应时间限制 （根据实际情况选择）。在此种情况下，年轻代收集发生的频率也是最小的。同时，减少到达年老代的对象。
	吞吐量优先的应用 ：尽可能的设置大，可能到达Gbit的程度。因为对响应时间没有要求，垃圾收集可以并行进行，一般适合8CPU以上的应用。
2. 年老代大小选择
	1. 响应时间优先的应用 ：
	年老代使用并发收集器，所以其大小需要小心设置，一般要考虑并发会话率 和会话持续时间 等一些参数。如果堆设置小了，可以会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式；如果堆大了，则需要较长的收集时间。最优化的方案，一般需要参考以下数据获得：
		* 并发垃圾收集信息
		* 持久代并发收集次数
		* 传统GC信息
		* 花在年轻代和年老代回收上的时间比例
	减少年轻代和年老代花费的时间，一般会提高应用的效率
	2. 吞吐量优先的应用 ：
	一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代。原因是，这样可以尽可能回收掉大部分短期对象，减少中期的对象，而年老代尽存放长期存活对象。
3. 较小堆引起的碎片问题
	因为年老代的并发收集器使用标记、清除算法，所以不会对堆进行压缩。当收集器回收时，他会把相邻的空间进行合并，这样可以分配给较大的对象。但是，当堆空间较小时，运行一段时间以后，就会出现“碎片”，如果并发收集器找不到足够的空间，那么并发收集器将会停止，然后使用传统的标记、清除方式进行回收。如果出现“碎片”，可能需要进行如下配置：
		-XX:+UseCMSCompactAtFullCollection ：使用并发收集器时，开启对年老代的压缩。
		-XX:CMSFullGCsBeforeCompaction=0 ：上面配置开启的情况下，这里设置多少次Full GC后，对年老代进行压缩





* 回收器选择
JVM给了三种选择：*串行收集器*、*并行收集器*、*并发收集器* ，但是串行收集器只适用于小数据量的情况，所以这里的选择主要针对并行收集器和并发收集器。默认情况下，JDK5.0以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0以后，JVM会根据当前系统配置进行判断。
	1. 吞吐量优先的 并行收集器
	如上文所述，并行收集器主要以到达一定的吞吐量为目标，适用于科学技术和后台处理等。
	典型配置 ：`java -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20`
	-XX:+UseParallelGC ：选择垃圾收集器为并行收集器。 此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。
	-XX:ParallelGCThreads=20 ：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。
	java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20 -XX:+UseParallelOldGC
	-XX:+UseParallelOldGC ：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集。
	java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100
	-XX:MaxGCPauseMillis=100 : 设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。
	java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100 -XX:+UseAdaptiveSizePolicy
	-XX:+UseAdaptiveSizePolicy ：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。
	2. 响应时间优先的 并发收集器
	如上文所述，并发收集器主要是保证系统的响应时间，减少垃圾收集时的停顿时间。适用于应用服务器、电信领域等。
	典型配置 ：`java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC`
	-XX:+UseConcMarkSweepGC ：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。
	-XX:+UseParNewGC :设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。
	java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection
	-XX:CMSFullGCsBeforeCompaction ：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。
	-XX:+UseCMSCompactAtFullCollection ：打开对年老代的压缩。可能会影响性能，但是可以消除碎片

* 堆大小的典型设置：
        1. `java -Xmx3550m -Xms3550m -Xmn2g -Xss128k`
```
-Xmx3550m ：
设置JVM最大可用内存为3550M。
-Xms3550m ：
设置JVM初始内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。
-Xmn2g ：
设置年轻代大小为2G。整个堆大小 = 年轻代大小 + 年老代大小 + 持久代大小 。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。
-Xss128k ：
设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。
```
        2. `java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m`
```
-XX:MaxTenuringThreshold=0
-XX:NewRatio=4 :
设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5
-XX:SurvivorRatio=4 ：
设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6
-XX:MaxPermSize=16m :
设置持久代大小为16m。
-XX:MaxTenuringThreshold=0 ：
设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代 。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间 ，增加在年轻代即被回收的概论。
```

