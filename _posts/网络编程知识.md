---
title: 网络编程知识
categories:
  - 笔记
tags:
  - null
date: 2019-04-22 15:22:31
---
 这是摘要
 <!-- more -->

## 网络模型
### 模型对比
{% asset_img x层协议对比.png x层协议对比%}

### OSI七层模型
{% asset_img OSI七层网络协议.gif OSI七层协议模型%}

### 五层模型
1. 在向下的过程中，需要添加下层协议所需要的首部或者尾部
2. 中间经过路由器的时候为了读取MAC地址和IP地址会拆包,拆到网络层
2. 在向上的过程中不断拆开首部和尾部
{% asset_img 网络层级结构图.png 网络层级结构%}
{% asset_img 数据包传输过程.jpg 数据包传输过程%}

### 从设计者角度看流程
>参考地址:http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html

#### 物理层
电缆连接计算机,传输电信号,
### 数据链路层(MAC地址)
1. 以太网协议(Ethernet):定义01信号的意义
2. MAC地址:前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。
3. 广播:子网中进行广播

#### 网络层(IP地址)
简历主机到主机之间的通信
1. 由于一台电脑不可能接受世界上所有电脑的数据包,所以全世界广播是不可能的,需要新的寻址方法
2. "网络层"出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。
3. 网络层使用IP协议,根据IP协议找到子网络,在子网络中通过MAC地址找到具体的计算机
	1. 互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。
	2. 通过IP地址和子网掩码来确定网段
	比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。
4. 如何获取目标IP地址主机的MAC地址
	1. 如果不在同一个子网,那么只能通过网关(gateway)处理
	2. 如果在同一个子网则通过ARP(Address Resolution Protocol)协议,也是通过广播询问对方(某个IP地址)的MAC地址

#### 传输层(端口号)
"传输层"的功能，就是建立"端口到端口"的通信。只要确定主机和端口，我们就能实现程序之间的交流。
1. UDP协议和TCP协议
{% post_link tcp和udp %}


#### 应用层(http协议)
{% post_link http协议 %}
应用程序收到"传输层"的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。
**"应用层"的作用，就是规定应用程序的数据格式。**
{% asset_img 数据包格式.png 数据包格式%}

### 从用户角度看流程
参考地址:http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html
### 电脑是如何上网的
1. 设置静态IP
也就是手动设置固定的:
	1. IP地址
	2. 子网掩码
	3. 网关的IP地址
	4. 还有DNS的IP地址
2. 设置动态IP(DHCP协议)
这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做"DHCP服务器"。新的计算机加入网络，必须向"DHCP服务器"发送一个"DHCP请求"数据包，申请IP地址和相关的网络参数。
{% asset_img DHCP数据包.png DHCP数据包%}
	1. 数据包格式
		1. 最前面的"以太网标头"，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。
		2. 后面的"IP标头"，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。然后广播的时候DHCP服务器就知道这个数据包是发给自己的
		3. 最后的"UDP标头"，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。
	2. 原理
	这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道"这个包是发给我的"，而其他计算机就可以丢弃这个包。
	接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个"DHCP响应"数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。
3. DNS(domain name service)协议
IP 8.8.8.8  端口 53
获取域名对应的IP地址,现在开始,假设要浏览器要访问Google:
	1. 首先会通过DNS得到Google服务器的IP地址
	2. 判断得到不是同一个网段,所以请求需要通过网关转发处理
	3. 于是确定是数据包的目的IP地址为Google服务器的IP地址,目的MAC地址为同网关的MAC地址,目的端口号80
4. 走5层网络模型
	1. 应用层
	浏览器根据http协议,打包数据
	2. 传输层
	按照TCP协议,打包数据,加入端口号
	3. 网络层 
	按照IP协议打包数据,加入IP地址
	4. 数据链路层
	按照以太网协议打包数据,加入MAC地址
	5. 物理层
	传输电信号
因为以太网协议的数据包最大长度为1500字节,所有请求可能会被分为几个数据包来发送
5. Google服务器收到请求
将收到的数据包按照IP头标号顺序拼接,读取最终的数据后,进行处理并返回response

---

## tcp、udp、http、https等常用协议
### tcp协议
#### 简介
* TCP支持的应用协议主要有：Telnet、FTP、SMTP,http,pop3等； 
* 应用场景
优点:可靠稳定,通过三次握手建立连接,有流量控制,差错控制等机制(握手 确认 窗口 拥塞控制 重传等)
缺点:传输速度慢,效率低,占用系统资源高,容易被攻击(DOS,DDOS,CC,通过大量建立无效连接来耗光服务器资源)
	1. 文件传输:FTP
	2. 邮件:SMTP
	3. putty:ssh,TELNET
	4. 浏览器:http
DOS攻击:denial of service
DDOS攻击:distributed denial of service	

>参考地址:https://www.jianshu.com/p/dff5a0d537d8

#### 三次握手与四次关闭
* 建立连接过程(3次握手)
{%asset_img tcp3次握手.png %}
1. C发送一个请求连接的位码SYN和一个随机产生的序列号给Seq，然后S收到了这些数据。
2. S收到了这个请求连接的位码，啊呀，有人向我发出请求了么，那我要不要接受他的请求，得实现确认一下，于是，发送了一个确认码 ACN（seq+1），和SYN，Seq给C，然后C收到了，这个是第二次连接。
3. C收到了确认的码和之前发送的SYN一比较，偶哟，对上了么，于是他又发送了一个ACN（SEQ+1）给S，S收到以后就确定建立连接，至此，TCP连接建立完成。
**为什么要3次:**
一端(client)A发出去的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到连接释放以后的某个时间才到达另一端(server)B。
本来这是一个早已失效的报文段，但是B收到此失效的报文之后，会误认为是A再次发出的一个新的连接请求，于是B端就向A又发出确认报文，表示同意建立连接。如果不采用“三次握手”，那么只要B端发出确认报文就会认为新的连接已经建立了，但是A端并没有发出建立连接的请求，因此不会去向B端发送数据，B端没有收到数据就会一直等待，这样B端就会白白浪费掉很多资源。
如果采用“三次握手”的话就不会出现这种情况，B端收到一个过时失效的报文段之后，向A端发出确认，此时A并没有要求建立连接，所以就不会向B端发送确认，这个时候B端也能够知道连接没有建立。

* 断开连接过程(4次挥手)
{% asset_img tcp4次挥手.png %}
1. 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
2. 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
3. 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
4. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
5. 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
6. 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。
为了确保数据能够完成传输。
关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。

#### 流量控制和拥塞控制
* 流量控制
参考地址:https://blog.csdn.net/yechaodechuntian/article/details/25429143
使用滑动窗口来控制流量,限制发送端可以发送的数据量
{% asset_img 滑动窗口控制流量.jpg 滑动窗口控制流量 %}

* 拥塞控制
发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。
1. 慢开始和拥塞避免
    1. 当 cwnd < ssthresh 时，使用慢开始算法,每次经过一轮传输,cwnd就扩大一倍。
    2. 当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。
    3. 当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。
    4. 当网络出现拥塞的时候,将ssthresh设置成当前cwnd的一半(但是不能小于2),重新执行慢开始算法
2. 慢开始算法
一开始将cwnd设置为1,每经过一个传输轮次，拥塞窗口 cwnd 就加倍。
3. 拥塞避免算法
让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。
{% asset_img 慢开始和拥塞避免.jpg 慢开始和拥塞避免 %}

3. 快重传和快恢复
  1. 快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。
  2. 当发送方连续收到3次重复确认消息,就会直接发送对应的数据包,并且将ssthresh减半,开始使用快恢复算法(即从新的ththresh开始拥塞避免算法)

{% asset_img 快重传和快恢复.jpg 快重传和快恢复 %}
#### tcp粘包与拆包

#### tcp和udp比较
{% asset_img tcp和udp比较.png tcp和udp比较%}


### udp协议
1. UDP支持的应用层协议主要有：NFS（网络文件系统）、SNMP（简单网络管理协议）、DNS（主域名称系统）、TFTP（通用文件传输协议）等。
2. 应用场景
优点:因为是无状态传输协议,所以传输速度很快;因为没有各种控制机制,容易被利用的漏洞较少(但是也有UDP FLOOD攻击)
缺点:不稳定,不可靠,网络条件差的情况下容易丢包
	1. 在线视频:
	2. 语音通话
	3. TFTP
---

### http协议
#### 特点
1. 简单快速
请求方法非常简单,只需要传送请求方法和路径
2. 灵活
可以传输任意类型的数据,使用content-type标记
3. 无连接
每次连接仅处理一个请求,服务器处理完客户端的请求并收到应答后即断开连接,节省传输时间
http1.1版本已经默认使用长连接,使用`Connection: close`关闭
4. 无状态
不记录请求的状态,加快应答

#### http请求方法
1. GET(幂等,无副作用,不能带Request Body)
获取资源
2. POST(非幂等,有副作用,能带Request Body)
新建或者更新资源
RFC文档例举的使用场景:
```java
- Annotation of existing resources;
- Posting a message to a bulletin board, newsgroup, mailing list, or   
  similar group of articles;
- Providing a block of data, such as the result of submitting a
  form, to a data-handling process;
- Extending a database through an append operation.
```
3. PUT(幂等,有副作用,能带Request Body)
更新资源,如修改帖子,同一个修改不管提交几次都是一样的结果
4. DELETE(幂等,有副作用,不能带Request Body)
删除资源
5. PATCH()
更新资源的一部分
6. HEAD
HEAD方法跟GET方法相同，只不过服务器响应时不会返回消息体。一个HEAD请求的响应中，HTTP头中包含的元信息应该和一个GET请求的响应消息相同。这种方法可以用来获取请求中隐含的元信息，而不用传输实体本身。也经常用来测试超链接的有效性、可用性和最近的修改。

#### 关于GET,POST,PUT的区别
1. 很多浏览器对GET请求的URI长度有限制
2. GET请求是安全的(对服务器而言),因为不会改变什么
3. 

#### 请求和响应
http1.0规定请求头或者响应头的数据格式必须是ASCII码,后面的数据可以是任意类型
1. get请求
```java
//请求行
GET / HTTP/1.1		//第一行指定请求方法和协议版本号,后面的都是描述客户端情况

//请求头
Transfer-Encoding: chunked
Accept-Encoding: gzip, deflate 		//指定可以接受的压缩类型
Accept-Language: zh-CN,zh;q=0.8
Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3
Connection: close	//明确要求服务器关闭tcp连接,在http1.0还只有短连接的时候请求头中需要声明keep-alive来保持连接
Accept: */*	 		//指定客户端可以接收的数据类型
```

2. post请求
```java
POST / HTTP1.1 //请求行
//请求头
Host:www.wrox.com
User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)
Content-Type:application/x-www-form-urlencoded
Content-Length:40
Connection: Keep-Alive
//数据
name=Professional%20Ajax&publisher=Wiley
```

3. 响应
```java
//响应行
HTTP/1.1 200 OK //第一行是协议版本和状态码

//响应头
Content-Type: text/plain	//说明response-body中的数据格式
Content-Length: 137582		//本次回应的数据长度,1.1中一个tcp连接可以回应多个请求
Transfer-Encoding: chunked	//分块传输,返回数据长度不定
Server: Apache 0.84			//服务器类型
Content-Encoding: gzip		//说明数据的压缩类型

//响应数据
<html>
  <body>Hello World</body>
</html>
```

#### 常见http协议状态码
```
1xx：指示信息--表示请求已接收，继续处理
2xx：成功--表示请求已被成功接收、理解、接受
3xx：重定向--要完成请求必须进行更进一步的操作
4xx：客户端错误--请求有语法错误或请求无法实现
5xx：服务器端错误--服务器未能实现合法的请求
```
```java
200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。
201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。
202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）
204 NO CONTENT - [DELETE]：用户删除数据成功。
400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。
401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。
403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。
404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。
406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。
410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。
422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。
500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。
```

### HTTPS 
#### aes与sra加密
1. aes是对称加密,秘钥只有一个,一般是256bit,
优点是加密速度快,
缺点是在不安全的网络中传输容易别窃取
2. sra是非对称加密,分为公钥和私钥,公钥在网络中传输,私钥安全保存,
优点是网络传输更安全,
缺点是加密速度相对较慢
3. 结合两者:
将公钥给对方,让对方用公钥加密aes的秘钥,然后发回给自己,自己通过私钥解密获得aes秘钥后加密数据发给对方,对方就能用公用的aes秘钥解密,
这样既能保证加密速度,又能保证秘钥传输安全

#### 非对称加密
1. 公钥加密,私钥解密
2. 私钥签名,公钥认证
3. 其实公钥私钥可以相互解密

#### SSL层
实现安全连接
* 工作原理
重点为:加密/解密,认证和数据完整性
* 证书
证书包括以下内容:
1. 公钥
2. 公钥的发布者
3. 证书的发行机构
4. 证书到期的时间戳
证书类型有:
1. 域名型SSL证书(DVSSL Domain Validation SSL)
	审核内容:域名 管理权限
	证书详情:使用者身份只显示某某域名
	一般用途:个人站点 IOS应用分发下载 登录等纯HTTPS加密需求的链接
2. 企业型SSL(OVSSL Organization Validation SSL)
	审核内容:域名管理权限 企业名称,地址,电话等信息的真实性
	证书详情:使用证身份显示公司名称
	一般用途:企业站点
3. 增强型SSL(EVSSL extend Validation SSL)
	审核内容:域名管理权限 企业名称地址电话等信息的真实性 第三方数据库的审查,例如邓白氏,114查号台,律师证明等
	证书详情:显示使用者显示公司名称
	一般用途:企业官网,电商,P2P等互联网金融网站

* 数字签名
签名的目的是为了检查文件是否完整(被篡改)
1. 生成原文件的摘要
2. 使用私钥对摘要进行加密
3. 客户端通过对比使用公钥解密的摘要和重新生成的摘要判断消息完整性

* 证书颁布过程
1. Bob生成公钥和私钥,Bob用自己的公钥向证书机构申请证书,
2. 证书机构通过自己的私钥加密Bob的公钥,Bob的信息,证书机构的信息以及证书到期时间戳来生成证书

* 认证过程
1. Alice想要与Bob建立安全连接
2. Bob将自己的证书发给Alice,通过证书机构的公钥解密证书(如果证书是假的,则解密出来就有问题)可以获得Bob的公钥
3. Bob发送消息和私钥加密后的消息摘要(如果Bob是假的,那么生成的消息摘要Alice解密出来会有问题)给Alice
4. Alice通过从证书中获取的公钥解密摘要,通过对比重新生成的摘要判断Bob身份的真实性


#### Socket通信
1. java封装类
2. 阻塞和非阻塞
	1. Java服务器网络开发时， 请说明通讯中阻塞（blocking）/非阻塞（non-blocking 与 同步/异步IO的区别。
	    1. 同步／异步主要针对客户端：
	        同步：就是当客户端发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是说必须一件一件的事情去做，等一件做完了才能去做下一件。
	        异步：就是当客户端发出一个功能调用时，调用者不用等接收方发出响应。实际处理这个调用的部件在完成后，会通过状态，通知和回调来通知调用者。客户端可以接着去做 后面的事情。
	        虽然主要是针对客户端，但是服务器端不是完全没有关系的，同步／异步必须配合服务器端才能实现。同步／异步是由客户端自己控制，但是服务器端是否阻塞/非阻塞，客户端完全不需要关心。
	    2. 阻塞／非阻塞主要是针对服务器端：
	        阻塞：阻塞调用是指服务器端被调用者调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
	        非阻塞：指在不能立即得到结果之前，该调用不会阻塞当前线程。
	        
{% post_link NIO的使用 %}

#### HTTPS 握手机制：
1. 客户端 向服务器发起请求。
2. 服务端 取出公有密钥及证书并发送给客户端。
3. 客户端判断公有密钥是否有效，无效则显示警告。有效则生成一个随机数串，并以此生成客户端的对称密钥。
4. 用步骤 2 到的公有密钥对该随机数串加密，发送到服务器。
5. 服务器得到加密报文，用私有密钥解密报文，得到随机数串，并以此生成服务器端的对称密钥。此时客户端和服务端拥有相同的对称密钥，可以用该对称密钥进行安全通信。
6. 服务器对响应进行加密，客户端对报文进行解密。

#### 跨站请求伪造
CSRF:Cross—Site Request Forgery
参考地址:http://blog.csdn.net/stpeace/article/details/53512283
过程:
1. me登录网易邮箱
2. hack制作了钓鱼网站
3. me在没有登出邮箱的时候访问了钓鱼网站
4. 于是钓鱼网站通过me的浏览器访问了网易邮箱,带着me的cookie(此时me的浏览器与网易邮箱网站服务器之间的session尚未过期)进行了一些操作

##### 防御CSRF攻击
1. 验证HTTP referer字段
HTTP referer指向前一个网页的URL,而hack要发起跨站请求伪造的话只能通过他的钓鱼网站发起,合法的HTTP referer一般都是网易邮箱的页面的URL.但是这种方法依赖于浏览器的安全性和设置,浏览器可以设置成不带上referer值
2. 在请求地址中添加token并验证
服务器生成token发给客户端,然后客户端发起请求的时候带上token
GET将token放在URL后面
POST则将请求放在form标签最后加上`<input type="hidden" name="token" value="tokenValue">` 
但是一些论坛网站中token很难保证安全,以为用户可以自己发帖子,然后帖子中的链接就会带上token
3. 在HTTP头中增加自定义属性并验证

## http/1.0 http/1.1 http/2之间的区别

## http/3

## Java RMI，Socket，HttpClient

## cookie 与 session
>参考地址:https://www.javazhiyin.com/12939.html 

### 会话跟踪的方式
1. URL重写
通过URL带上会话ID
2. 隐藏表单域
将会话ID添加到HTML表单提交到服务器

### cookie
客户端可以保存在内存中(临时cookie),也可以保存到硬盘上(有效期cookie),
用cookie写一个历史浏览记录

### session
session依赖于cookie
* 用session实现购物记录
1. session的原理 
2. 设置session的有效期 
3. 浏览器禁用Cookie后servlet共享数据导致的问题:url重写
* session的常见应用
1. 登录 
2. 防止表单重复提交 前台javaScript 后台表单带随机数 
3. 实现一次性校验码
实现带验证码的登录

### cookie被禁用，如何实现session

## 用Java写一个简单的静态文件的HTTP服务器

## 了解nginx和apache服务器的特性并搭建一个对应的服务器

## 用Java实现FTP、SMTP协议

## 进程间通讯的方式

## 什么是CDN？如果实现？
1. cdn
内容分发网络(content delivery network)

>参考地址:https://www.jianshu.com/p/57433bc34659

## DNS？

什么是DNS 、记录类型:A记录、CNAME记录、AAAA记录等

域名解析、根域名服务器

DNS污染、DNS劫持、公共DNS：114 DNS、Google DNS、OpenDNS

## 代理
### 正向代理
{% asset_img 正向代理.png 正向代理 %}
正向代理的用途
1. 突破访问限制
通过代理服务器，可以突破自身IP访问限制，访问国外网站，教育网等。
2. 提高访问速度 通常代理服务器都设置一个较大的硬盘缓冲区，会将部分请求的响应保存到缓冲区中，当其他用户再访问相同的信息时,则直接由缓冲区中取出信息，传给用户，以提高访问速度。
3. 隐藏客户端真实IP 
上网者也可以通过这种方法隐藏自己的IP，免受攻击。

### 反向代理
{% asset_img 反向代理.png 反向代理%}
1. 隐藏服务器真实IP 
使用反向代理，可以对客户端隐藏服务器的IP地址。
2. 负载均衡 
反向代理服务器可以做负载均衡，根据所有真实服务器的负载情况，将客户端请求分发到不同的真实服务器上。
3. 提高访问速度 
反向代理服务器可以对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务，提高访问速度。
4. 提供安全保障 
反向代理服务器可以作为应用层防火墙，为网站提供对基于Web的攻击行为（例如DoS/DDoS）的防护，更容易排查恶意软件等。还可以为后端服务器统一提供加密和SSL加速（如SSL终端代理），提供HTTP访问认证等。

### 反向代理服务器