---
title: 5层网络模型
categories:
  - 网络
tags:
  - IP地址
  - MAC地址
  - 
date: 2018-07-28 16:44:03
---
 这是摘要
 <!-- more -->

# OSI七层协议模型
{% asset_img OSI七层网络协议.gif OSI七层协议模型%}

# 五层网络模型
1. 在向下的过程中，需要添加下层协议所需要的首部或者尾部
2. 中间经过路由器的时候为了读取MAC地址和IP地址会拆包,拆到网络层
2. 在向上的过程中不断拆开首部和尾部
{% asset_img 网络层级结构图.png 网络层级结构%}
{% asset_img 数据包传输过程.jpg 数据包传输过程%}


# 对比
{% asset_img x层协议对比.png x层协议对比%}

## 设计者角度
参考地址:http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html
### 物理层
电缆连接计算机,传输电信号,
### 数据链路层(MAC地址)
1. 以太网协议(Ethernet):定义01信号的意义
2. MAC地址:前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。
3. 广播:子网中进行广播

### 网络层(IP地址)
简历主机到主机之间的通信
1. 由于一台电脑不可能接受世界上所有电脑的数据包,所以全世界广播是不可能的,需要新的寻址方法
2. "网络层"出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。
3. 网络层使用IP协议,根据IP协议找到子网络,在子网络中通过MAC地址找到具体的计算机
	1. 互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。
	2. 通过IP地址和子网掩码来确定网段
	比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。
4. 如何获取目标IP地址主机的MAC地址
	1. 如果不在同一个子网,那么只能通过网关(gateway)处理
	2. 如果在同一个子网则通过ARP(Address Resolution Protocol)协议,也是通过广播询问对方(某个IP地址)的MAC地址

### 传输层(端口号)
"传输层"的功能，就是建立"端口到端口"的通信。只要确定主机和端口，我们就能实现程序之间的交流。
1. UDP协议和TCP协议
{% post_link tcp和udp %}


### 应用层(http协议)
{% post_link http协议 %}
应用程序收到"传输层"的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。
**"应用层"的作用，就是规定应用程序的数据格式。**
{% asset_img 数据包格式.png 数据包格式%}

## 用户角度
参考地址:http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html
### 电脑是如何上网的
1. 设置静态IP
也就是手动设置固定的:
	1. IP地址
	2. 子网掩码
	3. 网关的IP地址
	4. 还有DNS的IP地址
2. 设置动态IP(DHCP协议)
这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做"DHCP服务器"。新的计算机加入网络，必须向"DHCP服务器"发送一个"DHCP请求"数据包，申请IP地址和相关的网络参数。
{% asset_img DHCP数据包.png DHCP数据包%}
	1. 数据包格式
		1. 最前面的"以太网标头"，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。
		2. 后面的"IP标头"，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。然后广播的时候DHCP服务器就知道这个数据包是发给自己的
		3. 最后的"UDP标头"，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。
	2. 原理
	这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道"这个包是发给我的"，而其他计算机就可以丢弃这个包。
	接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个"DHCP响应"数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。
3. DNS(domain name service)协议
IP 8.8.8.8  端口 53
获取域名对应的IP地址,现在开始,假设要浏览器要访问Google:
	1. 首先会通过DNS得到Google服务器的IP地址
	2. 判断得到不是同一个网段,所以请求需要通过网关转发处理
	3. 于是确定是数据包的目的IP地址为Google服务器的IP地址,目的MAC地址为同网关的MAC地址,目的端口号80
4. 走5层网络模型
	1. 应用层
	浏览器根据http协议,打包数据
	2. 传输层
	按照TCP协议,打包数据,加入端口号
	3. 网络层 
	按照IP协议打包数据,加入IP地址
	4. 数据链路层
	按照以太网协议打包数据,加入MAC地址
	5. 物理层
	传输电信号
因为以太网协议的数据包最大长度为1500字节,所有请求可能会被分为几个数据包来发送
5. Google服务器收到请求
将收到的数据包按照IP头标号顺序拼接,读取最终的数据后,进行处理并返回response























