---
title: tcp和udp
categories:
  - 网络 
tags:
  - tcp 
  - udp
  - 流量控制
date: 2018-07-28 17:04:08
---
 这是摘要
 <!-- more -->


### tcp和udp比较
{% asset_img tcp和udp比较.png tcp和udp比较%}

### tcp协议
1. TCP支持的应用协议主要有：Telnet、FTP、SMTP,http,pop3等； 
2. 流量控制
参考地址:https://blog.csdn.net/yechaodechuntian/article/details/25429143
使用滑动窗口来控制流量,限制发送端可以发送的数据量
{% asset_img 滑动窗口控制流量.jpg 滑动窗口控制流量 %}

3. 拥塞控制
发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。
    1. 慢开始和拥塞避免
        1. 当 cwnd < ssthresh 时，使用慢开始算法,每次经过一轮传输,cwnd就扩大一倍。
        2. 当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。
        3. 当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。
        4. 当网络出现拥塞的时候,将ssthresh设置成当前cwnd的一半(但是不能小于2),重新执行慢开始算法
    2. 慢开始算法
    一开始将cwnd设置为1,每经过一个传输轮次，拥塞窗口 cwnd 就加倍。
    3. 拥塞避免算法
    让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。
{% asset_img 慢开始和拥塞避免.jpg 慢开始和拥塞避免 %}

    2. 快重传和快恢复
      1. 快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。
      2. 当发送方连续收到3次重复确认消息,就会直接发送对应的数据包,并且将ssthresh减半,开始使用快恢复算法(即从新的ththresh开始拥塞避免算法)

{% asset_img 快重传和快恢复.jpg 快重传和快恢复 %}

4. 应用场景
优点:可靠稳定,通过三次握手建立连接,有流量控制,差错控制等机制(握手 确认 窗口 拥塞控制 重传等)
缺点:传输速度慢,效率低,占用系统资源高,容易被攻击(DOS,DDOS,CC,通过大量建立无效连接来耗光服务器资源)
	1. 文件传输:FTP
	2. 邮件:SMTP
	3. putty:ssh,TELNET
	4. 浏览器:http
DOS攻击:denial of service
DDOS攻击:distributed denial of service	
参考地址:https://www.jianshu.com/p/dff5a0d537d8
5. 建立连接过程(3次握手)
{%asset_img tcp3次握手.png %}

	1. C发送一个请求连接的位码SYN和一个随机产生的序列号给Seq，然后S收到了这些数据。
  2. S收到了这个请求连接的位码，啊呀，有人向我发出请求了么，那我要不要接受他的请求，得实现确认一下，于是，发送了一个确认码 ACN（seq+1），和SYN，Seq给C，然后C收到了，这个是第二次连接。
  3. C收到了确认的码和之前发送的SYN一比较，偶哟，对上了么，于是他又发送了一个ACN（SEQ+1）给S，S收到以后就确定建立连接，至此，TCP连接建立完成。
**为什么要3次:**
一端(client)A发出去的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到连接释放以后的某个时间才到达另一端(server)B。
本来这是一个早已失效的报文段，但是B收到此失效的报文之后，会误认为是A再次发出的一个新的连接请求，于是B端就向A又发出确认报文，表示同意建立连接。如果不采用“三次握手”，那么只要B端发出确认报文就会认为新的连接已经建立了，但是A端并没有发出建立连接的请求，因此不会去向B端发送数据，B端没有收到数据就会一直等待，这样B端就会白白浪费掉很多资源。
如果采用“三次握手”的话就不会出现这种情况，B端收到一个过时失效的报文段之后，向A端发出确认，此时A并没有要求建立连接，所以就不会向B端发送确认，这个时候B端也能够知道连接没有建立。

6. 断开连接过程(4次挥手)
{% asset_img tcp4次挥手.png %}
  1. 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
  2. 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
  3. 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
  4. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
  5. 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
  6. 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。
为了确保数据能够完成传输。
关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。


### udp协议
1. UDP支持的应用层协议主要有：NFS（网络文件系统）、SNMP（简单网络管理协议）、DNS（主域名称系统）、TFTP（通用文件传输协议）等。
2. 应用场景
优点:因为是无状态传输协议,所以传输速度很快;因为没有各种控制机制,容易被利用的漏洞较少(但是也有UDP FLOOD攻击)
缺点:不稳定,不可靠,网络条件差的情况下容易丢包
	1. 在线视频:
	2. 语音通话
	3. TFTP
