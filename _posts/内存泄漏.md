---
title: 内存泄漏
categories:
  - 笔记
tags:
  - 内存泄漏
date: 2018-09-26 16:27:13
---
 这是摘要
 <!-- more -->


### 内存泄漏
指的就是不会再被使用的对象的内存却不能被回收
{% asset_img 内存泄漏的原因.png 内存泄漏%}

### 可能出现内存泄漏的情况
1. 长生命周期的对象持有短生命周期对象的引用
```java
public class Simple {
	Object object;
	public void method1(){
		object = new Object();
		//...其他代码
		//object = null;
	}
}
```
比如说这种情况就可能会出现内存泄漏,如果object对象只在method1()方法中使用,其实应该写成局部变量,或者在方法结束的地方释放掉.

2. 移动数组中的指针来实现移除元素,但是没有解除引用
```java
public E pop(){
	if(size == 0)
		return null;
	else
		return (E) elementData[--size];//此时elementData[size]元素还保持引用,无法被回收
}
```

3. 可以调用close()方法关闭资源的类
```java
try{
	session=sessionFactory.openSession();
/	/...其他操作
}finally{
	session.close();//如果不close的话,session对象只有在sessionFactory对象被回收,才能被回收
}
```

3. 静态集合类引起
```java
static Vector v = new Vector(10); 
for (int i = 1; i<100; i++) { 
	Object o = new Object(); 
	v.add(o); 
	o = null; //此时v中的数组依然持有对象的引用
} 
```

4. 集合中元素的属性被修改,如果重写了hashCode()方法,可能会引起泄漏
```java
public static void main(String[] args) { 
	Set<Person> set = new HashSet<Person>(); 
	Person p1 = new Person("唐僧","pwd1",25); 
	Person p2 = new Person("孙悟空","pwd2",26); 
	Person p3 = new Person("猪八戒","pwd3",27); 
	set.add(p1); 
	set.add(p2); 
	set.add(p3); 

	p3.setAge(2); //修改p3的年龄,此时p3元素对应的hashcode值发生改变 
	set.remove(p3); //此时remove不掉，造成内存泄漏
	set.add(p3); //重新添加，居然添加成功 
}
```

### 内存泄漏的排查方法
1. 主要工具
Optimizeit Profiler，JProbe Profiler，JinSight , Rational 公司的Purify等
2. 方法
在运行过程中，我们可以随时观察内存的使用情况，通过这种方式，我们可以很快找到那些长期不被释放，并且不再使用的对象。我们通过检查这些对象的生存周期，确认其是否为内存泄露。
3. 总结
在实践当中，寻找内存泄露是一件非常麻烦的事情，它需要程序员对整个程序的代码比较清楚，并且需要丰富的调试经验，但是这个过程对于很多关键的Java程序都是十分重要的。

### 实践案例
1. 案例一
>参考地址:https://my.oschina.net/jenwang/blog/833207

2. 步骤
	1. 使用`jstat -gcutil pid time`查看gc状态(pid:线程号,time:多少时间打印一次)
{% asset_img jstat查看状态.png jstat%}
	可以观察到fullgc频繁
	2. 使用`jmap -histo:live pid`查看内存使用情况,打印存活对象状态
{% asset_img jmap查看内存.png jmap%}
	可以看出HashTable中的元素有5000多万，占用内存大约1.5G的样子
	3. 定位代码
	接下来自然要看看是什么代码往HashTable里疯狂的put数据，于是用神器btrace跟踪Hashtable.put调用的堆栈。
	编写btrace脚本`TracingHashTable.java`,然后运行`bin/btrace -cp build 4947 TracingHashTable.java`
```java
import com.sun.btrace.annotations.*;
import static com.sun.btrace.BTraceUtils.*;

@BTrace
public class TracingHashTable {
        /*指明要查看的方法，类*/
        @OnMethod(
            clazz="java.util.Hashtable",
            method="put",
            location=@Location(Kind.RETURN))
        public static void traceExecute(@Self java.util.Hashtable object){
                println("调用堆栈！！");
                jstack();
        }
}
```
{% asset_img btrace跟踪调用栈.png btrace跟踪调用栈%}
可以看出是在接收到消息后查询入库的代码造成的，业务方法调用ibatis再到mysql jdbc驱动执行statement时put了大量的属性到HashTable中。



























