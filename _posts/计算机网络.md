---
title: 计算机网络
categories:
  - 网络
tags:
  - http
date: 2018-07-07 20:49:17
---
 计算机网络相关知识
 <!-- more -->


# 网络编程
>参考地址:https://www.javazhiyin.com/12939.html 


## SSL工作原理
重点为:加密/解密,认证和数据完整性
### 证书
证书包括以下内容:
1. 公钥
2. 公钥的发布者
3. 证书的发行机构
4. 证书到期的时间戳

### 数字签名
签名的目的是为了检查文件是否完整(被篡改)
1. 生成原文件的摘要
2. 使用私钥对摘要进行加密
3. 客户端通过对比使用公钥解密的摘要和重新生成的摘要判断消息完整性

### 证书颁布过程
1. Bob生成公钥和私钥,Bob用自己的公钥向证书机构申请证书,
2. 证书机构通过自己的私钥加密Bob的公钥,Bob的信息,证书机构的信息以及证书到期时间戳来生成证书

### 认证过程
1. Alice想要与Bob建立安全连接
2. Bob将自己的证书发给Alice,通过证书机构的公钥解密证书(如果证书是假的,则解密出来就有问题)可以获得Bob的公钥
3. Bob发送消息和私钥加密后的消息摘要(如果Bob是假的,那么生成的消息摘要Alice解密出来会有问题)给Alice
4. Alice通过从证书中获取的公钥解密摘要,通过对比重新生成的摘要判断Bob身份的真实性



## cookie和session
### Cookie
用cookie写一个历史浏览记录
### session
*用session实现购物记录*
1. session的原理 
2. 设置session的有效期 
3. 浏览器禁用Cookie后servlet共享数据导致的问题:url重写
*session的常见应用*
1. 登录 
2. 防止表单重复提交 前台javaScript 后台表单带随机数 
3. 实现一次性校验码
实现带验证码的登录

## 过滤器filter
### CrossFilter
```java
public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletResponse response= (HttpServletResponse) servletResponse;
        String origin= servletRequest.getRemoteHost()+":"+servletRequest.getRemotePort();
        response.setHeader("Access-Control-Allow-Origin", "*");
        response.setHeader("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept");
        response.setHeader("Access-Control-Allow-Methods","POST,GET,OPTIONS,DELETE");
       /* response.setHeader("Access-Control-Allow-Methods","POST,GET,OPTIONS,DELETE");
        response.setHeader("Access-Control-Max-Age","3600");
        response.setHeader("Access-Control-Allow-Credentials","true");*/
        filterChain.doFilter(servletRequest,servletResponse);
    }
```
### HtmlFilter
(防止XSS攻击)
参考地址:http://blog.csdn.net/qq924862077/article/details/62053577
```java 
import javax.servlet.*;
import javax.servlet.http.HttpServletResponse;
@WebFilter("/HtmlFilter")
public class HtmlFilter implements Filter {

	public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException {
		HttpServletRequest request = (HttpServletRequest) req;
		HttpServletResponse response = (HttpServletResponse) resp;
		MyHtmlRequest htmlRequest = new MyHtmlRequest(request);
		chain.doFilter(htmlRequest, response);
	}

	class MyHtmlRequest extends HttpServletRequestWrapper{
		public MyHtmlRequest(HttpServletRequest request) {
			super(request);
		}
		@Override
		public String getParameter(String name) {
			
			String value = super.getParameter(name);
			if(value == null) return null;

			return filter(value);
		}
		
		public  String filter(String message) {
	        if (message == null)
	            return (null);
	        char content[] = new char[message.length()];
	        message.getChars(0, message.length(), content, 0);
	        StringBuilder result = new StringBuilder(content.length + 50);
	        for (int i = 0; i < content.length; i++) {
	            switch (content[i]) {
	            case '<':
	                result.append("&lt;");
	                break;
	            case '>':
	                result.append("&gt;");
	                break;
	            case '&':
	                result.append("&amp;");
	                break;
	            case '"':
	                result.append("&quot;");
	                break;
	            default:
	                result.append(content[i]);
	            }
	        }
	        return (result.toString());
	    }
	}
}
```
### CharactorFilter
```java
import javax.servlet.*;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet Filter implementation class CharacterEncodingFilter
 */
@WebFilter("/CharacterEncodingFilter")
public class CharacterEncodingFilter implements Filter {
	private String charset ;
	private String defaultCharset = "UTF-8";

	public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException {
		HttpServletRequest request = (HttpServletRequest) req;
		HttpServletResponse response = (HttpServletResponse) resp;
		request.setCharacterEncoding(charset);
		response.setCharacterEncoding(charset);
		response.setContentType("text/html;charset=" + charset);
		request.setAttribute("charset", charset);	
		chain.doFilter(new MyRequest(request), response);
	}

	public void init(FilterConfig fConfig) throws ServletException {
		String charset = fConfig.getInitParameter("charset");
		if(charset == null){
			charset = defaultCharset;
		}
		this.charset = charset;
	}

}

class MyRequest extends HttpServletRequestWrapper{
	private HttpServletRequest request;
	public MyRequest(HttpServletRequest request) {
		super(request);
		this.request = request;
	}
	@Override
	public String getParameter(String name) {
		String value = request.getParameter(name);
		if(value == null) return null;
		if(!request.getMethod().equals("get")){
			return value;
		}
		try {
			value = new String(value.getBytes("ios8859-1"),request.getParameter("charset"));
		} catch (UnsupportedEncodingException e) {
			throw new RuntimeException(e);
		}
		return value;
	}
}
```
