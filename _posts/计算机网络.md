---
title: 计算机网络
categories:
  - 笔记
tags:
  - http
date: 2018-07-07 20:49:17
---
 计算机网络相关知识
 <!-- more -->

## tcp和udp
1. tcp 
2. udp
3. 区别

## aes与sra加密
1. aes是对称加密,秘钥只有一个,一般是256bit,
优点是加密速度快,
缺点是在不安全的网络中传输容易别窃取
2. sra是非对称加密,分为公钥和私钥,公钥在网络中传输,私钥安全保存,
优点是网络传输更安全,
缺点是加密速度相对较慢
3. 结合两者:
将公钥给对方,让对方用公钥加密aes的秘钥,然后发回给自己,自己通过私钥解密获得aes秘钥后加密数据发给对方,对方就能用公用的aes秘钥解密,
这样既能保证加密速度,又能保证秘钥传输安全


## 拥塞控制

## 超时重传

## 滑动窗口

## 常见协议
TCP/IP协议族
### http协议
1. 在向下的过程中，需要添加下层协议所需要的首部或者尾部
2. 在向上的过程中不断拆开首部和尾部
{% asset_img 网络层级结构图.png 网络层级结构%}

### tcp协议
1. TCP支持的应用协议主要有：Telnet、FTP、SMTP,http,pop3等； 
2. 流量控制
参考地址:https://blog.csdn.net/yechaodechuntian/article/details/25429143
使用滑动窗口来控制流量,限制发送端可以发送的数据量
{% asset_img 滑动窗口控制流量.jpg 滑动窗口控制流量 %}

3. 拥塞控制
发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。
    1. 慢开始和拥塞避免
        1. 当 cwnd < ssthresh 时，使用上述的慢开始算法。
        2. 当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。
        3. 当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。
{% asset_img 慢开始和拥塞避免.jpg 慢开始和拥塞避免 %}

    2. 快重传和快恢复
{% asset_img 快重传和快恢复.jpg 快重传和快恢复 %}
       

### udp协议
1. UDP支持的应用层协议主要有：NFS（网络文件系统）、SNMP（简单网络管理协议）、DNS（主域名称系统）、TFTP（通用文件传输协议）等。
## 常见http协议端口号

## HTTPS 握手机制：
1. 客户端 向服务器发起请求。
2. 服务端 取出公有密钥及证书并发送给客户端。
3. 客户端判断公有密钥是否有效，无效则显示警告。有效则生成一个随机数串，并以此生成客户端的共享密钥。
4. 用步骤 2 到的公有密钥对该随机数串加密，发送到服务器。
5. 服务器得到加密报文，用私有密钥解密报文，得到随机数串，并以此生成服务器端的共享密钥。此时客户端和服务端拥有相同的共享密钥，可以用该共享密钥进行安全通信。
6. 服务器对响应进行加密，客户端对报文进行解密。

## 跨站请求伪造
CSRF:Cross—Site Request Forgery
参考地址:http://blog.csdn.net/stpeace/article/details/53512283
过程:
1. me登录网易邮箱
2. hack制作了钓鱼网站
3. me在没有登出邮箱的时候访问了钓鱼网站
4. 于是钓鱼网站通过me的浏览器访问了网易邮箱,带着me的cookie(此时me的浏览器与网易邮箱网站服务器之间的session尚未过期)进行了一些操作

### 防御CSRF攻击
1. 验证HTTP referer字段
HTTP referer指向前一个网页的URL,而hack要发起跨站请求伪造的话只能通过他的钓鱼网站发起,合法的HTTP referer一般都是网易邮箱的页面的URL.但是这种方法依赖于浏览器的安全性和设置,浏览器可以设置成不带上referer值
2. 在请求地址中添加token并验证
服务器生成token发给客户端,然后客户端发起请求的时候带上token
GET将token放在URL后面
POST则将请求放在form标签最后加上`<input type="hidden" name="token" value="tokenValue">` 
但是一些论坛网站中token很难保证安全,以为用户可以自己发帖子,然后帖子中的链接就会带上token
3. 在HTTP头中增加自定义属性并验证

## DHCP
1. 数据包格式
2. 原理

# 网络编程
## 阻塞和非阻塞
1. Java服务器网络开发时， 请说明通讯中阻塞（blocking）/非阻塞（non-blocking 与 同步/异步IO的区别。
    1. 同步／异步主要针对客户端：
        同步：就是当客户端发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是说必须一件一件的事情去做，等一件做完了才能去做下一件。
        异步：就是当客户端发出一个功能调用时，调用者不用等接收方发出响应。实际处理这个调用的部件在完成后，会通过状态，通知和回调来通知调用者。客户端可以接着去做 后面的事情。
        虽然主要是针对客户端，但是服务器端不是完全没有关系的，同步／异步必须配合服务器端才能实现。同步／异步是由客户端自己控制，但是服务器端是否阻塞/非阻塞，客户端完全不需要关心。
    2. 阻塞／非阻塞主要是针对服务器端：
        阻塞：阻塞调用是指服务器端被调用者调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
        非阻塞：指在不能立即得到结果之前，该调用不会阻塞当前线程。
## cookie和session
### Cookie
用cookie写一个历史浏览记录
### session
*用session实现购物记录*
1. session的原理 
2. 设置session的有效期 
3. 浏览器禁用Cookie后servlet共享数据导致的问题:url重写
*session的常见应用*
1. 登录 
2. 防止表单重复提交 前台javaScript 后台表单带随机数 
3. 实现一次性校验码
实现带验证码的登录

## 过滤器filter
### CrossFilter
```java
public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletResponse response= (HttpServletResponse) servletResponse;
        String origin= servletRequest.getRemoteHost()+":"+servletRequest.getRemotePort();
        response.setHeader("Access-Control-Allow-Origin", "*");
        response.setHeader("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept");
        response.setHeader("Access-Control-Allow-Methods","POST,GET,OPTIONS,DELETE");
       /* response.setHeader("Access-Control-Allow-Methods","POST,GET,OPTIONS,DELETE");
        response.setHeader("Access-Control-Max-Age","3600");
        response.setHeader("Access-Control-Allow-Credentials","true");*/
        filterChain.doFilter(servletRequest,servletResponse);
    }
```
### HtmlFilter
(防止XSS攻击)
参考地址:http://blog.csdn.net/qq924862077/article/details/62053577
```java 
import javax.servlet.*;
import javax.servlet.http.HttpServletResponse;
@WebFilter("/HtmlFilter")
public class HtmlFilter implements Filter {

	public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException {
		HttpServletRequest request = (HttpServletRequest) req;
		HttpServletResponse response = (HttpServletResponse) resp;
		MyHtmlRequest htmlRequest = new MyHtmlRequest(request);
		chain.doFilter(htmlRequest, response);
	}

	class MyHtmlRequest extends HttpServletRequestWrapper{
		public MyHtmlRequest(HttpServletRequest request) {
			super(request);
		}
		@Override
		public String getParameter(String name) {
			
			String value = super.getParameter(name);
			if(value == null) return null;

			return filter(value);
		}
		
		public  String filter(String message) {
	        if (message == null)
	            return (null);
	        char content[] = new char[message.length()];
	        message.getChars(0, message.length(), content, 0);
	        StringBuilder result = new StringBuilder(content.length + 50);
	        for (int i = 0; i < content.length; i++) {
	            switch (content[i]) {
	            case '<':
	                result.append("&lt;");
	                break;
	            case '>':
	                result.append("&gt;");
	                break;
	            case '&':
	                result.append("&amp;");
	                break;
	            case '"':
	                result.append("&quot;");
	                break;
	            default:
	                result.append(content[i]);
	            }
	        }
	        return (result.toString());
	    }
	}
}
```
### CharactorFilter
```java
import javax.servlet.*;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet Filter implementation class CharacterEncodingFilter
 */
@WebFilter("/CharacterEncodingFilter")
public class CharacterEncodingFilter implements Filter {
	private String charset ;
	private String defaultCharset = "UTF-8";

	public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException {
		HttpServletRequest request = (HttpServletRequest) req;
		HttpServletResponse response = (HttpServletResponse) resp;
		request.setCharacterEncoding(charset);
		response.setCharacterEncoding(charset);
		response.setContentType("text/html;charset=" + charset);
		request.setAttribute("charset", charset);	
		chain.doFilter(new MyRequest(request), response);
	}

	public void init(FilterConfig fConfig) throws ServletException {
		String charset = fConfig.getInitParameter("charset");
		if(charset == null){
			charset = defaultCharset;
		}
		this.charset = charset;
	}

}

class MyRequest extends HttpServletRequestWrapper{
	private HttpServletRequest request;
	public MyRequest(HttpServletRequest request) {
		super(request);
		this.request = request;
	}
	@Override
	public String getParameter(String name) {
		String value = request.getParameter(name);
		if(value == null) return null;
		if(!request.getMethod().equals("get")){
			return value;
		}
		try {
			value = new String(value.getBytes("ios8859-1"),request.getParameter("charset"));
		} catch (UnsupportedEncodingException e) {
			throw new RuntimeException(e);
		}
		return value;
	}
}
```

## SSL证书 
1. 域名型SSL证书(DVSSL Domain Validation SSL)
	审核内容:域名 管理权限
	证书详情:使用者身份只显示某某域名
	一般用途:个人站点 IOS应用分发下载 登录等纯HTTPS加密需求的链接
2. 企业型SSL(OVSSL Organization Validation SSL)
	审核内容:域名管理权限 企业名称,地址,电话等信息的真实性
	证书详情:使用证身份显示公司名称
	一般用途:企业站点
3. 增强型SSL(EVSSL extend Validation SSL)
	审核内容:域名管理权限 企业名称地址电话等信息的真实性 第三方数据库的审查,例如邓白氏,114查号台,律师证明等
	证书详情:显示使用者显示公司名称
	一般用途:企业官网,电商,P2P等互联网金融网站
