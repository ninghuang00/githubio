---
title: 单例模式
categories:
  - 笔记
tags:
  - 单例模式
date: 2018-08-04 15:42:53
---
 参考地址:http://www.hollischuang.com/archives/2498
 <!-- more -->

## 反序列化破坏单例性
参考地址:http://www.hollischuang.com/archives/1144
### 为什么会被破坏
因为反序列化过程中,是通过反射调用无参构造函数来创建新的对象
1. 实现可序列化的单例
```java
public class Singleton implements Serializable{
    private volatile static Singleton singleton;
    private Singleton (){}
    public static Singleton getSingleton() {
        if (singleton == null) {
            synchronized (Singleton.class) {
                if (singleton == null) {
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
```
2. 序列化和反序列化
```java
public class SerializableDemo1 {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        //Write Obj to file
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("tempFile"));
        oos.writeObject(Singleton.getSingleton());
        //Read Obj from file
        File file = new File("tempFile");
        ObjectInputStream ois =  new ObjectInputStream(new FileInputStream(file));
        Singleton newInstance = (Singleton) ois.readObject();
        //判断是否是同一个对象
        System.out.println(newInstance == Singleton.getSingleton());
    }
}
//false
```

### 解决方法
在Singleton中,实现serializable 或者 externalizable接口的类中包含readResolve()方法，并在该方法中指定要返回的对象的生成策略，这样一来,在反序列化的过程中,使用反射生成新对象之前会判断一下有没有实现这个方法,如果实现了,就会使用过这个方法中的生成策略返回单例对象,这样就可以防止单例被破坏。

## 双重校验锁实现单例,并且实现安全的序列化
```java
public class Singleton implements Serializable{
    private volatile static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
    //反序列化得到的instance是通过反射生成的新对象
    //实现接口中的该方法后,可以防止反序列化破坏单例性,因为instance对象反序列化之后会调用该方法来返回,而不是反射生成新对象
    private Object readResolve() {
        return singleton;
    }
}
```

## 枚举实现单例
```java
public enum Singleton {  
    INSTANCE;  
    public void whateverMethod() {  
    }  
}  
```
1. 枚举实现单例的线程安全
反编译枚举类得到代码发现,类中的几个属性和方法都是static类型的，因为static类型的属性会在类被加载之后被初始化,当一个Java类第一次被真正使用到的时候静态资源被初始化、Java类的加载和初始化过程都是线程安全的（因为虚拟机在加载枚举的类的时候，会使用ClassLoader的loadClass方法，而这个方法使用同步代码块保证了线程安全）。所以，创建一个enum类型是线程安全的。
也就是说，我们定义的一个枚举，在第一次被真正用到的时候，会被虚拟机加载并初始化，而这个初始化过程是线程安全的。而我们知道，解决单例的并发问题，主要解决的就是初始化过程中的线程安全问题。
所以，由于枚举的以上特性，枚举实现的单例是天生线程安全的。

2. 枚举可解决反序列化会破坏单例的问题 
枚举的反序列化并不是通过反射实现的。
