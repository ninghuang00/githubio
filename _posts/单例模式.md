---
title: 单例模式
categories:
  - 笔记
tags:
  - 单例模式
date: 2018-08-04 15:42:53
---
 参考地址:http://www.hollischuang.com/archives/2498
 <!-- more -->

## 反序列化破坏单例性
参考地址:http://www.hollischuang.com/archives/1144
```java
public class SerializableDemo1 {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        //Write Obj to file
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("tempFile"));
        oos.writeObject(Singleton.getSingleton());
        //Read Obj from file
        File file = new File("tempFile");
        ObjectInputStream ois =  new ObjectInputStream(new FileInputStream(file));
        Singleton newInstance = (Singleton) ois.readObject();
        //判断是否是同一个对象
        System.out.println(newInstance == Singleton.getSingleton());
    }
}
//false
```

## 双重校验锁实现单例
```java
public class Singleton {
    private volatile static Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
    //反序列化得到的instance是通过反射生成的新对象
    //实现接口中的该方法后,可以防止反序列化破坏单例性,因为instance对象反序列化之后会调用该方法来返回,而不是反射生成新对象
    private Object readResolve() {
        return singleton;
    }
}
```

## 枚举实现单例
```java
public enum Singleton {  
    INSTANCE;  
    public void whateverMethod() {  
    }  
}  
```
1. 枚举实现单例的线程安全
当一个Java类第一次被真正使用到的时候静态资源被初始化、Java类的加载和初始化过程都是线程安全的（因为虚拟机在加载枚举的类的时候，会使用ClassLoader的loadClass方法，而这个方法使用同步代码块保证了线程安全）。所以，创建一个enum类型是线程安全的。
也就是说，我们定义的一个枚举，在第一次被真正用到的时候，会被虚拟机加载并初始化，而这个初始化过程是线程安全的。而我们知道，解决单例的并发问题，主要解决的就是初始化过程中的线程安全问题。
所以，由于枚举的以上特性，枚举实现的单例是天生线程安全的。
2. 枚举可解决反序列化会破坏单例的问题 
枚举的反序列化并不是通过反射实现的。
