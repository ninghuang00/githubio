---
title: 数据库事务
categories:
  - 笔记
tags:
  - 数据库
  - 事务
date: 2018-08-12 21:17:25
---
 参考地址:http://www.hollischuang.com/archives/898

 <!-- more -->

## 命令行
1. 查看隔离级别
`SELECT @@tx_isolation;`
2. 查看存储引擎
`show variables like '%storage_engine%';`

## 锁
1. 行级锁
行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。
开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
	1. 排它锁(写锁)
	`SELECT ... FOR UPDATE;`
	排他锁又称写锁，如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。
	2. 共享锁(读锁)
	`SELECT ... LOCK IN SHARE MODE;`
	如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。

2. 表级锁
表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。
开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。
	1. 表共享读锁(共享锁)
	2. 表独占写锁(排他锁)
	3. 意向共享锁(IS)
	4. 意向互斥锁(IX)
>有的人可能会对意向锁(intention lock)的目的并不是完全的理解，我们在这里可以举一个例子：如果没有意向锁，当已经有人使用行锁对表中的某一行进行修改时，如果另外一个请求要对全表进行修改，那么就需要对所有的行是否被锁定进行扫描，在这种情况下，效率是非常低的；不过，在引入意向锁之后，当有人使用行锁对表中的某一行进行修改之前，会先为表添加意向互斥锁（IX），再为行记录添加互斥锁（X），在这时如果有人尝试对全表进行修改就不需要判断表中的每一行数据是否被加锁了，只需要通过等待意向互斥锁被释放就可以了。
3. 页级锁
页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。一次锁定相邻的一组记录。BDB支持页级锁

## 锁算法
1. 记录锁
记录锁（Record Lock）是加到索引记录上的锁,如果我们使用 id 或者 last_name 作为 SQL 中 WHERE 语句的过滤条件，那么 InnoDB 就可以通过索引建立的 B+ 树找到行记录并添加索引，但是如果使用 first_name 作为过滤条件时，由于 InnoDB 不知道待修改的记录具体存放的位置，也无法对将要修改哪条记录提前做出判断就会锁定整个表。
2. 间隙锁
间隙锁是对索引记录中的一段连续区域的锁；当使用类似 `SELECT * FROM users WHERE id BETWEEN 10 AND 20 FOR UPDATE;` 的 SQL 语句时，就会阻止其他事务向表中插入 `id = 15 `的记录，因为整个范围都被间隙锁锁定了。
3. next-key锁(解决幻读)
当我们更新一条记录，比如 `SELECT * FROM users WHERE age = 30 FOR UPDATE;`，InnoDB 不仅会在范围 (21, 30] 上加 Next-Key 锁，还会在这条记录后面的范围 (30, 40] 加间隙锁，所以插入 (21, 40] 范围内的记录都会被锁定。

## 事务概念
一个数据库事务通常包含对数据库的读或写的一个操作序列,它存在的目的如下:
1. 为数据库操作提供一个从失败状态恢复到正常状态的方法,同时提供了数据库即使在异常状态也能保持一致性的方法
2. 当多个应用程序并发访问数据库时,提供隔离这些操作的方法,避免操作之间相互干扰

## 事务特性(ACID)
数据库事务:银行转账的例子
1. 原子性(atomicity)
事务中对数据库的一系列操作要么全部被执行,要么都不执行
2. 一致性(consistent)
从一个一致性状态变到另一个一致性状态,满足数据库的完整性约束
3. 隔离性(isolation)
多个事务并发执行的时候,一个事务不会影响到另一个事务
4. 持久性(Durability)
事务一旦提交成功,对数据库的修改将永久保存在数据库中

## 事务的隔离级别
参考地址:http://www.hollischuang.com/archives/943
1. 未提交读(read Uncommited)
	* 概念
	一个事务可以读取另一个事务未提交的数据
	* 实现
	事务读取数据的时候不加锁
	事务修改数据的时候加行级共享锁
	* 可能现象
	出现脏读
2. 提交读(read committed) 
	* 概念
	在一个事务修改数据过程中，如果事务还没提交，其他事务不能读该数据。解决脏读
	* 实现
	事务对当前被读取的数据加 行级共享锁（当读到时才加锁），一旦读完该行，立即释放该行级共享锁；
	事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。
	* 可能现象
	不可重复读:对于同一数据项,前面读取的数据和后来读取的数据可能不一样
	可能出现不可重复读和幻读
3. 可重复读(repeated read) 
	* 概念
	可重复读,只有在事务一提交之后，事务二才能更改该行数据。所以，只要在事务一从开始到结束的这段时间内，无论他读取该行数据多少次，结果都是一样的。解决不可重复读
	* 实现
	事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 行级共享锁，直到事务结束才释放；
	事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。
	innodb中使用快照技术,即晚于当前事务的其他的事务的更新对本事务不可见
	* 可能现象
	数据库进行读事务的时候就会禁止其他的写事务,进行写事务的时候就会禁止其他任何事务写操作
	可能出现幻读,因为其他事务虽然不能修改该行数据,但是可以新增数据行,
4. 可序列化(serializable) 
	* 概念
	可序列化:最高级别,事务串行,解决幻读
	* 实现
	事务在读取数据时，必须先对其加 表级共享锁 ，直到事务结束才释放；
	事务在更新数据时，必须先对其加 表级排他锁 ，直到事务结束才释放。
	* 可能现象
	虽然可序列化解决了脏读、不可重复读、幻读等读现象。但是序列化事务会产生以下效果：
		1. 无法读取其它事务已修改但未提交的记录。
		2. 在当前事务完成之前，其它事务不能修改目前事务已读取的记录。
		3. 在当前事务完成之前，其它事务所插入的新记录，其索引键值不能在当前事务的任何语句所读取的索引键范围中。


## 由于低级别隔离性产生的问题:
1. 脏读:session1查询test为空,此时session2插入数据不提交,然后session再次查询test就有数据了
{% asset_img 脏读.jpg 脏读 %}
提交读解决脏读的方法在于,当session2插入数据的时候加了排他行锁,直到session2提交才能被访问到
2. 不可重复读:session1查询id=3的地方v=2,此时session2把v改成3并且提交,session1再次查询id=2的地方v变成了3,同一事务前后访问不一致,重点在同一条记录
{% asset_img 不可重复读.jpg 不可重复读 %}
可重复读解决不可重复读的方法在于,当session1读取数据的时候加了共享行锁,知道session1结束才释放,所以session2无法修改数据
3. 幻读:重点在插入了新数据,session1查询返回结果为空表,此时session2插入新数据1并提交,(图中有误,第二次查询应去掉)然后事务1也插入数据1,此时报错,刚刚明明是空表,现在却提示数据冲突.
{% asset_img 幻读.jpg 幻读 %}
出现幻读的原因是可重复读虽然加了行锁,但是无法阻止数据的插入,解决的办法就是加表锁,还有乐观锁机制?


## mysql常用存储引擎
1. MyISAM和MEMORY采用表级锁(table-level locking)
	1. 在myisam中是不会出现死锁的,因为一次性获取所有需要的锁要么全部满足,要么全部等待
2. BDB采用页面锁(page-level locking)或表级锁，默认为页面锁
3. InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁
innodb中的行锁实现原理是在索引中的索引项上加锁,所以只有通过索引条件检索数据InnoDB才会使用行锁,否则使用的是表锁
	实际应用:
	1. 因为MySQL行锁是针对索引,而不是记录,所以使用相同的索引键,即使是访问不同的行也会产生锁冲突
	2. 如果一张表使用多个索引,那么可以根据不同的索引键访问不同的行
在MySQL中，行级锁并不是直接锁记录，而是锁索引。索引分为主键索引和非主键索引两种，如果一条sql语句操作了主键索引，MySQL就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。 在UPDATE、DELETE操作时，MySQL不仅锁定WHERE条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的next-key locking。
当两个事务同时执行，一个锁住了主键索引，在等待其他相关索引。另一个锁定了非主键索引，在等待主键索引。这样就会发生死锁。
发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。
参考地址:https://draveness.me/mysql-innodb

### InnoDb和MyISAM的区别
> 参考地址:https://juejin.im/post/5b02b105f265da0b7868d230

|InnoDb|MyISAM|
|------|--------|
|I支持行级锁和表级锁;行级锁基于索引实现,只对where的主键有效|M只支持表级锁|
|提供事务支持|M强调性能,不支持事务|
|支持外键|不支持外键|
|适合大量的insert和update|适合大量的select|
|适合写多,字段更新频繁,高并发,安全可用性高|读多写少,并发小,表数据量小,硬件资源有限|
|数据文件,binlog,mysqldump|数据以文件形式存储,数据转移方便|

## 产生死锁的可能:
{% asset_img 死锁的发生.jpg 死锁的发生 %}
1. 事务1获取数据a的锁,想要访问数据b,但是此时数据b被事务2锁定,而事务2希望访问数据a,陷入相互等待的局面.
解决的方式就是从根源上避免这种情况的出现,就是修改程序逻辑,避免出现环,可以一开始就将所有要用到的资源锁定
还有就是采用抢占和回滚机制,根据时间戳来判断事务应该回滚还是等待

## 避免死锁的方式
1. 如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。
2. 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；
3. 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；

## 并发控制机制
参考地址:http://www.hollischuang.com/archives/934
1. 悲观锁(是真正的锁)
就是之前的共享锁和互斥锁(排它锁),就是不管如何,想要修改数据之前先加锁,可能会产生死锁
2. 乐观锁(其实是一种并发控制思想,基于时间戳或者版本号)
这种思想假设数据操作的时候一般不会产生冲突,只有在最后要写回数据的时候检测数据是否发生了变化,发生冲突的话进行重试或者返回错误信息让用户决定怎么处理,否则就可以正常写回
在整个执行过程中实际上并没有加任何锁,在要求响应速度和高并发的场景下适合,不会产生死锁,但是在高冲突频率重试成本的情况下还是建议使用悲观锁
	1. 版本控制:就是为数据的每一个写操作创建版本,在进行读操作的时候就会在有限多的版本中选择最合适的返回
	通常是在数据表中增加一列version,然后写回数据的时候比对version
	2. 基于时间戳




