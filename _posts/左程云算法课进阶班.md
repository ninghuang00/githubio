---
title: 左程云算法课进阶班
categories:
  - 算法
tags:
  - 算法
date: 2018-07-08 11:00:50
---
 左程云算法课进阶班
 代码地址:https://gitee.com/ninghuang/swordTOOffer/tree/master/src/cn/hn/algoriththm
 <!-- more -->


## 设计一种可以变更的缓存结构
1. LRU缓存算法(Least Recently Used)
{% asset_img 设计缓存结构.png 设计缓存结构%}
2. LFU缓存算法(Least Frequently Used)
{% asset_img LFU缓存算法.png LFU缓存算法 %}


## 二叉搜索树套路
{% asset_img 二叉搜索树的可能性分析.png 二叉搜索树的可能性分析%}
* 选择一个节点进行可能性分析:
    1. 最大子树来自左子树中
    2. 最大子树来自右子树中
    3. 这个节点就是二叉搜索树(判断信息需要左右子树中的最大二叉搜索树的头结点,左最大值,右最小值)
1. 查找一棵树中的最大二叉搜索子树

2. 返回树中最大最小值
(% asset_img 子树套路返回树中最大最小值.png 子树套路返回树中最大最小值)
3. 树中两个节点的最长距离
{% asset_img 树中两个节点的最长距离1.png 树中两个节点的最长距离}
{% asset_img 树中两个节点的最长距离.png 树中两个节点的最长距离}
4. 聚会活跃度
{% asset_img 聚会活跃度.png 聚会活跃度%}
可能性分析:假设当前节点为head
    1. 如果head来,那么当前节点的来_活跃度就是所有子节点不来的活跃度总和
    2. 如果head不来,那么当前节点的不来_活跃度就是子节点来或者不来活跃度中大的那个的总和
{% asset_img 聚会活跃度图解.png 聚会活跃度%}


## 二叉平衡搜索树
所谓二叉搜索树就是树中每一个节点的左子树都比自己小,右子树都比自己大
平衡性指的是左右子树的规模差不多
1. 搜索节点
2. 插入节点
3. 删除节点
    1. 没有左孩子或者右孩子
    直接拿另一边的子树顶上来
    2. 孩子双全
    拿右孩子的最左节点顶上来,最左节点如果有右子树,连到最左节点的父节点上
4. 调整平衡性
    基本操作只有左旋和右旋,在一个节点上发现不平衡时,右旋就是这个节点左子树不动,往右边的父节点变成右节点,该节点的右子树变成父节点的左子树
    1.  
5. 常见的二叉平衡搜索树
    1. AVL树
    严格的平衡搜索二叉树,左右子树层数差不超过一层
    2. SB树
    当前节点为根节点的子树,节点数量不能超过他的叔叔节点作为根节点的子树的节点数
    3. 红黑树

## 跳表
SkipListIterator(不同于红黑树的非树状设计)
{% asset_img 跳表结构.png 调表结构%}

## 二叉平衡搜索树应用
### 大楼轮廓
{% asset_img 大楼轮廓题目.png 大楼轮廓 %}
{% asset_img 大楼轮廓.png 大楼轮廓 %}


## Morris遍历
* 遍历二叉树的时间复杂度为还是O(N),但是额外空间复杂度为O(1)
{% asset_img Morris遍历标准1.png Morris遍历标准1 %}
{% asset_img Morris遍历实现.png  Morris遍历实现 %}


## 单调栈结构(进阶3-1)
>
求一个数左右两边最近的比自己大或者小的数

1. 给定一个数组,希望在O(N)时间内,获得数组中每一个数字的左右离这个数字最近的大于这个数字的数
    1. 将数组中的数依次压入栈,要求下大上小,当当前要进栈的数字a大于当前栈顶的数字b时,将栈顶的数字b弹出,此时当前数字a就是b右边最近的比b大的数,b弹出之后栈顶的数字就是b左边满足要求的数
    2. 碰到一样大的数字将下标放在一起
{% asset_img 单调栈.png 单调栈 %}

## 单调栈的应用(进阶3-1)
### 烽火台
{% asset_img 烽火台.png 烽火台%}
### 求最大子矩阵的大小
>cn.hn.advanced.MaximalRectangle.java
求矩阵中的最大子矩阵

1. 从第0行开始,到最后一行,求出以每一行为底的最大子矩阵
{% asset_img 求最大子矩阵的大小.png 求最大子矩阵的大小%}
{% asset_img 辅助数组求最大子矩阵.png 求最大子矩阵的大小%}
{% asset_img 求最大子矩阵的大小解法.png 求最大子矩阵的大小解法%}


### 构造数组的maxTree
>cn.hn.advanced.MaxTree.java

* 解法一
    1. 先建一个大根堆
    2. 变成树
* 解法二
    1. 使用单调栈找出每个数字左右的最近最大数信息
    2. 根据信息串联
{% asset_img 构造数组的maxTree.png 构造数组的maxTree%}
{% asset_img 单调栈建大根数.png 构造数组的maxTree%}

## 窗口结构(进阶2)
>MaxOfWindowUpdate.java

1. 窗口滑过数组,返回每次窗口中的最大值(窗口最大值更新结构)
	1. 准备一个双端队列,
	2. 队列加数逻辑:往队列尾部加元素下标,当前加的元素要是大于等于之前的元素,之前的元素的下标弹出
	3. 队列减数逻辑:窗口形成之后随着左边界移动从队列中移除对应下标,队列头为当前窗口最大值
{% asset_img 窗口结构.png 窗口结构 %}
{% asset_img 滑动窗口算法.png 滑动窗口算法 %}

### 窗口结构的应用(进阶2)
>cn.hn.advanced.AllLessNumSubArray
用于维持一个窗口中的最值

1. 求一个数组子数组的最大最小差值<=num的个数
	1. 一个子数组如果满足条件,那么这个子数组的所有子数组满足条件
	2. 一个子数组如果不满足条件,那么包含这个子数组的数组一定不满足条件
2. 准备一个窗口最大值更新结构,一个窗口最小值更新结构
3. L从0位置开始,R一直往右扩大,直到窗口中的(最大值-最小值)>num停,假设这个时候在X位置,那么以0位置开头的满足条件的子数组个数为(X+1)个
4. L移动到1位置,R继续往右,直到不满足条件,重复上述步骤
5. 时间复杂度就是遍历整个数组,O(N)
    
{% asset_img 滑动窗口解题思路.png 滑动窗口解题思路 %}
{% asset_img 窗口结构应用.png 窗口结构应用 %}


## BFPRT算法(进阶2)
>cn.hn.basic.BFPRT.java
在一个无序数组中找到第k大的数字,时间复杂度O(n)

1. 解法1:
    1. 使用partition函数,时间复杂度长期期望O(N),取决于分组情况,也就是partition中的pivot值选取
2. 解法2:主要是保证了pivot值的有效
	1. 将数组分成五个数一组(余数一组),每组取中位数,组成的数组再分组取中位数直到最后返回一个数(O(1)+O(N)+O(N)+T(N/5))
		1. 假设一次分组取中位数的过程为T(N),则第二次为T(N/5)
	2. 根据这个数字将数组分成左中右,判断k在不在中间(O(N))
	3. 根据判断选择左边或者右边继续以上步骤(T(7N/10))
	4. 时间复杂度为:T(N) = T(N/5)+T(7N/10)+O(N)
```java
//在begin和end范围上求,数组中第k小的数
public static int select(int[] arr, int begin, int end, int i) {
    if (begin == end)     return arr[begin];
    int pivot = medianOfMedians(arr, begin, end);//求中位数的中位数
    int[] pivotRange = partition(arr, begin, end, pivot);//使用partition函数求中间的范围
    if (i >= pivotRange[0] && i <= pivotRange[1]) {//是否命中
        return arr[i];
    } else if (i < pivotRange[0]) {//如果没命中,选一个方向继续找
        return select(arr, begin, pivotRange[0] - 1, i);
    } else {
        return select(arr, pivotRange[1] + 1, end, i);
    }
}
```

## KMP(进阶1)
>cn.hn.algoriththm.KMP.java
用来求解一个大字符串str1中是否包含小字符串str2

* 相关概念
    1. next数组:
    保存的是,字符串中,每一个字符之前的字符串中,最大的**前缀和后缀**匹配的长度.比如`abcdabce`,字符`e`的最长前缀和最长后缀的匹配长度为3,当前缀长度取3,后缀长度取3,这时前后缀都是`abc`,所以定义字符`e`的最长前缀和最长后缀的匹配长度为3,也就是next数组中,字符`e`所在位置的值为3.
    2. 应用的时候求的是短字符串的next数组,数组第一个元素为-1,第二个为0.
* next数组的求解方式
{% asset_img 求next数组.png 求next数组%}    
    1. 从左到右求解,根据之前一个字符的结果加速计算
    2. 求字符`a`的前缀长度时,根据`b`的前缀长度,只需判断x位置是否等于字符`b`
{% asset_img 求next数组.png 求next数组%}
    3. 如果不相等,继续尝试字符`c`的前缀
```java
public int[] getNext(String str) {
    char[] chars = str.toCharArray();
    int[] next = new int[chars.length];
    next[0] = -1;
    next[1] = 0;
    int pCur = 2;//指向要求最长前后缀匹配长度的字符
    int pn = 0;//当字符不匹配是用来左移的指针
    while (pCur < next.length) {
        //当前字符的前一个字符是否和之前最长前缀的后一个字符相等
        if (chars[pCur - 1] == chars[pn]) {
            next[pCur++] = ++pn;
        } else if (pn > 0) {    //将pn移到之前一个最长前缀
            pn = next[pn];
        } else {    //pn已经指向第一个字符了还是不匹配
            next[pCur++] = 0;
        }
    }
    return next;
}
```
* 加速原理
{% asset_img KMP加速原理.png KMP加速原理%}
    1. str1的i到x-1位置和str2的0到y-1位置都匹配,但是到了下一个位置就不匹配了
    2. 此时根据next数组可以得知str2中y位置的最长前缀和最长后缀匹配长度length
    3. 根据length,将str2的最长前缀,移动到最长后缀的位置(codeing的时候通过左移str2中的指针实现),从z位置继续尝试匹配
    4. 如果length为0,则从str1中x位置的下一个位置和str2的0位置从新开始尝试匹配
* 为什么流程正确
{% asset_img 为什么流程正确.png 为什么流程正确%}
    1. 假设str1中从k开始能和str2匹配上,
    2. 但是因为str1中,从j开始已经是最长后缀,所以1中的假设不成立
```java
public int isContain(String str1, String str2) {
    char[] chars1 = str1.toCharArray();
    char[] chars2 = str2.toCharArray();
    int i1 = 0;
    int i2 = 0;
    int[] next = getNext(str2);//获取next数组
    while (i1 < chars1.length && i2 < chars2.length) {
        if (chars1[i1] == chars2[i2]) {//字符匹配,指针一起右移
            i1++;
            i2++;
        } else if (next[i2] == -1) {//字符没配上,并且str2中的指针已经来到0位置,还是配不上,str1指针右移,从新开始尝试匹配
            i1++;
        } else {//根据前缀长度,左移str2的指针,继续尝试
            i2 = next[i2];
        }
    }
    return i2 == next.length ? i1 - i2 : -1;
}
```

### KMP算法应用
>cn.hn.basic.KMP_ShortestHaveTwice.java
有一个原始串`abcdeab`,在它的后面加上自己的子串,是的得到的新字符串中包含两个原始串,且开头位置不一样,求最短的那个加法,这里的答案是`abcdeabcdeab`

1. 求原始串的next数组,多求一位
2. 根据next数组最后一位求解,只要在后面加上除了最长前缀的部分即可

>cn.hn.basic.KMP_T1SubtreeEqualsT2.java
求一棵树是否是另一棵树的子树

1. 将两棵树序列化,然后用KMP算法计算
    
## Manacher算法(进阶1)
* 求解一个字符串中的最大回文子串长度
    1. 为了偶回文和奇回文都能用,要加#
    1. 回文半径数组
    2. 最右回文右边界R,此时的中心为C
* 可能性
    1. 当前字符不在回文右边界R里,暴力破解
    2. 当前字符在回文右边界R内
        1. 当前字符位置i关于C的对称点i'的回文半径在L内,那么i的回文半径等于i'的回文半径
        2. 要是回文半径在L外头,那么i的回文半径就是R
        3. 要是回文半径在L上,i的回文半径需要尝试
{% asset_img 最长回文可能性.png %}

### manacher应用
在一个字符串后面添加字符,让它变成回文,求最短
1. 就是求每一个字符的回文半径,当有一个字符的回文半径R达到最右边的时候,此时的L到开头位置就是要加的字符

