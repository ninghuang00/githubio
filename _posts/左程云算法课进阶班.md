---
title: 左程云算法课进阶班
categories:
  - 算法
tags:
  - 算法
date: 2018-07-08 11:00:50
---
 左程云算法课进阶班
 代码地址:https://gitee.com/ninghuang/swordTOOffer/tree/master/src/cn/hn/algoriththm
 <!-- more -->


## 二叉搜索树套路
{% asset_img 二叉搜索树的可能性分析.png 二叉搜索树的可能性分析%}
* 选择一个节点进行可能性分析:
    1. 最大子树来自左子树中
    2. 最大子树来自右子树中
    3. 这个节点就是二叉搜索树(判断信息需要左右子树中的最大二叉搜索树的头结点,左最大值,右最小值)
1. 查找一棵树中的最大二叉搜索子树

## 二叉平衡搜索树
所谓二叉搜索树就是树中每一个节点的左子树都比自己小,右子树都比自己大
平衡性指的是左右子树的规模差不多
1. 搜索节点
2. 插入节点
3. 删除节点
    1. 没有左孩子或者右孩子
    直接拿另一边的子树顶上来
    2. 孩子双全
    拿右孩子的最左节点顶上来,最左节点如果有右子树,连到最左节点的父节点上
4. 调整平衡性
    基本操作只有左旋和右旋,在一个节点上发现不平衡时,右旋就是这个节点左子树不动,往右边的父节点变成右节点,该节点的右子树变成父节点的左子树
    1.  
5. 常见的二叉平衡搜索树
    1. AVL树
    严格的平衡搜索二叉树,左右子树层数差不超过一层
    2. SB树
    当前节点为根节点的子树,节点数量不能超过他的叔叔节点作为根节点的子树的节点数
    3. 红黑树

## 二叉平衡搜索树应用
### 大楼轮廓
{% asset_img 大楼轮廓题目.png 大楼轮廓 %}
{% asset_img 大楼轮廓.png 大楼轮廓 %}

### 累加和为aim的最长子数组
(HashMap就行)
{% asset_img 累加和为aim的最长子数组.png 累加和为aim的最长子数组 %}
#### 变形
1. 一个数组中有奇数和偶数,求奇数和偶数数量相等的最长子数组
2. 数组异或和
{% asset_img 数组异或和.png 数组异或和 %}
{% asset_img 数组异或和代码.png 数组异或和代码 %}

## Morris遍历
* 遍历二叉树的时间复杂度为还是O(N),但是额外空间复杂度为O(1)
{% asset_img Morris遍历标准1.png Morris遍历标准1 %}
{% asset_img Morris遍历实现.png  Morris遍历实现 %}


## 单调栈结构
1. 给定一个数组,希望在O(N)时间内,获得数组中每一个数字的左右离这个数字最近的大于这个数字的数
    1. 将数组中的数依次压入栈,要求下大上小,当当前要进栈的数字a大于当前栈顶的数字b时,将栈顶的数字b弹出,此时当前数字a就是b右边最近的比吧大的数,b弹出之后栈顶的数字就是b左边满足要求的数
    2. 碰到一样大的数字将下标放在一起
{% asset_img 单调栈.png 单调栈 %}

## 单调栈的应用
### 烽火台
{% asset_img 烽火台.png 烽火台%}
### 求最大子矩阵的大小
{% asset_img 求最大子矩阵的大小.png 求最大子矩阵的大小%}
{% asset_img 求最大子矩阵的大小解法.png 求最大子矩阵的大小解法%}
### 构造数组的maxTree
{% asset_img 构造数组的maxTree.png 构造数组的maxTree%}

## 窗口结构
1. 窗口滑过数组,返回每次窗口中的最大值(窗口最大值更新结构)
	1. 准备一个双端队列,
	2. 往队列尾部加元素下标,当前加的元素要是大于等于之前的元素,之前的元素的下标弹出
	3. 窗口形成之后随着左边界移动从队列中移除对应下标,队列头为当前窗口最大值
{% asset_img 窗口结构.png 窗口结构 %}
{% asset_img 滑动窗口算法.png 滑动窗口算法 %}

### 窗口结构的应用
1. 求一个数组子数组的最大最小差值<=num的个数
	1. 一个子数组如果满足条件,那么这个子数组的所有子数组满足条件
	2. 一个子数组如果不满足条件,那么包含这个子数组的数组一定不满足条件
2. 准备一个窗口最大值更新结构,一个窗口最小值更新结构
3. L从0位置开始,R一直往右扩大,直到窗口中的(最大值-最小值)>num停,假设这个时候在X位置,那么以0位置开头的满足条件的子数组个数为(X+1)个
4. L移动到1位置,R继续往右,直到不满足条件,重复上述步骤
5. 时间复杂度就是遍历整个数组,O(N)
    
{% asset_img 滑动窗口解题思路.png 滑动窗口解题思路 %}
{% asset_img 窗口结构应用.png 窗口结构应用 %}


## BFPRT算法
1. 在一个无序数组中找到第k大的数字,时间复杂度O(n)
	1. 将数组分成五个数一组(余数一组),每组取中位数,组成的数组在分组取中位数直到最后返回一个数(O(1)+O(N)+O(N)+T(N/5))
		1. 假设一次分组取中位数的过程为T(N),则第二次为T(N/5)
	2. 根据这个数字将数组分成左中右,判断k在不在中间(O(N))
	3. 根据判断选择左边或者右边继续以上步骤(T(7N/10))
	4. 时间复杂度为:T(N) = T(N/5)+T(7N/10)+O(N)
	
{% asset_img bfprt算法主体.png bfprt算法主体 %}

## KMP
* 用来求解一个大字符串str1中是否包含小字符串str2
    1. next数组:每一个字符之前的最大相等前缀和后缀长度
    2. 通过next数组加速
        
### KMP算法应用
有一个原始串abcabc,在它的后面加上自己的子串,是的得到的新字符串中包含两个原始串,且开头位置不一样,求最短的那个加法
1. 求原始串的next数组
2. 根据next数组求解

## 求一棵树是否是另一棵树的子树
1. 将两棵树序列化,然后用KMP算法计算
    
## Manacher算法
* 求解一个字符串中的最大回文子串长度
    1. 为了偶回文和奇回文都能用,要加#
    1. 回文半径数组
    2. 最右回文右边界R,此时的中心为C
* 可能性
    1. 当前字符不在回文右边界R里,暴力破解
    2. 当前字符在回文右边界R内
        1. 当前字符位置i关于C的对称点i'的回文半径在L内,那么i的回文半径等于i'的回文半径
        2. 要是回文半径在L外头,那么i的回文半径就是R
        3. 要是回文半径在L上,i的回文半径需要尝试
{% asset_img 最长回文可能性.png %}

### manacher应用
在一个字符串后面添加字符,让它变成回文,求最短
1. 就是求每一个字符的回文半径,当有一个字符的回文半径R达到最右边的时候,此时的L到开头位置就是要加的字符

